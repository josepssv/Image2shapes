<!DOCTYPE html>
<html>

<head>
    <title>Turns an image into hundreds of them. Discover the shapes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <meta charset="utf-8">
    <script>
    </script>
    <style>
        html, body {
  margin: auto,auto;
  padding: 0;
  background-color:#111;
  font-size:20px;
  text-align:center;
  color:#444;
  font-family:arial;
}
canvas {
  display: block;
}
#drop-zone {
  border: 1px solid black;
  padding: 10px;
  background-color:#111;
  color:#ddd;
  height:200px;
}
.convert {
  background-color: #0000ff;
  color: white;
  padding: 10px 20px;
  margin: 20px 0;
  border-radius: 5px;
}
.butty {
 padding: 10px 20px;
  margin: 0;
 border-radius: 5px;
 height:40px;
}

.layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.empieza {
  font-size: 30px;
  color: white;
  text-align: center;
  font-family: "Roboto", sans-serif;
  position: relative;
  text-shadow: 1px 1px 2px #000;
 
}
.otracapa {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #555;

}
.preload {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #999;
}
.capadibujo {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background-color:#000;
  background-image: repeating-linear-gradient(36deg, rgba(15,19,15, 0.25), rgba(15,19,15, 0.25) 1px, transparent 0px, transparent 2px);
    content:".";
    display:block;
    clear:both;
    padding-bottom: 100px;
}
#canvasdiv {
  display: inline-block;
  text-align:center;
  position: relative;
}

table {
    background-color:#999;
    border-collapse:separate;
    border:solid black 1px;
    border-radius:6px;
    color: #000;
    display:inline-block;
}
#allimgs{
    margin-top:40px;
}
#myShape{
    margin-top:40px;
}
   .menu-container {
            position: fixed;
            top: 40px; /* Ajusta según la altura de tu zona superior */
            left: -250px; /* Oculta el menú inicialmente */
            width: 250px;
            height: 100%;
            background-color: #777777; /* Color de fondo del menú */
            transition: left 0.3s ease; 
            z-index: 3000;
        }

        .menu-content {
            padding: 20px;
            color: #ecf0f1; /* Color del texto del menú */
        }
    .toggle-button {
            position: fixed;
            top: 10px;
            left: 10px;
            cursor: pointer;
            z-index: 3001; /* Asegura que el botón esté encima del menú */
        }


</style>
</head>

<body>
    <main>
        <div id="header" style="position: fixed; top: 0; margin-top: 0;z-index:2000; padding-top: 0; vertical-align: top; width: 100%;  height: 40px; display:none;background-color:rgba(0,0,0,1);">
            <div class="toggle-button" onclick="toggleMenu()" style="position:absolute; top:0px;left:0px;font-size:32px;color:#aaa;">☰</div>
        </div>
        <div class="menu-container" id="menu">
            <div class="menu-content" style="font-size:16px;">
                <p class="selectShapesTypes" style="text-align: right;">
                    Colors <input type="checkbox" id="s-0" value="-0" class="selectType" checked><br>
                    Clips<input type="checkbox" id="s0" value="0" class="selectType" checked><br>
                    Lines and points <input type="checkbox" id="s1" value="1" class="selectType" checked><br>
                    Mix and random <input type="checkbox" id="s2" value="2" class="selectType" checked><br>
                    Triangles and radials <input type="checkbox" id="s3" value="3" class="selectType" checked><br>
                    Squares ad rings <input type="checkbox" id="s4" value="4" class="selectType" checked><br>
                    3D<input type="checkbox" id="s5" value="5" class="selectType" checked><br>
                </p>
                <p style="text-align: right;"><button type="button"  onclick="toggleMenu()" class="butty apply" style="">Apply</button></p>
                <div style="text-align: left;">
                    <p><a class="saveCode" style="">Save code</a>
                    <p class="nameapp"><i>Image2shapes 0.92</i></p>
                </div>
            </div>
        </div>
        <div class="layer">
            <div style="background-image:url(1000.png);display:inline-block;height:350px;width:680px;"></div>
            <h1 class="empieza" style="top:-300px;"><span style="font-size:20px;">Turns an image into hundreds of them </span><br>Discover the shapes<br>
                <button type="button" id="start" class="convert">Start</button>
            </h1>
        </div>
        <div class="otracapa" style="display:none;">
            <div id="drop-zone">
                <p>click to upload:</p>
                <div id="imageUpload"></div>
                <p style="display:none">Drag and drop files here to upload.</p>
            </div>
        </div>
        <div class="preload" style="display:none;"><br><span style="margin.top:100px;font-size:24px;">loading..</span></div>
        <div class="capadibujo" style="display:none;">
            <div id="bill" style="display:none;"></div>
            <div id="allimgs" style=""></div>
            <center>
            </center>
        </div>
        <div class="shape" style="z-index:3000;position:fixed;display:none;background-color:rgba(0,0,0,0.8);top:0px;left:0px;width:100%;height:100%;margin:0px;padding:0px;">
            <center>
                <div id="myShape" class="choid" style=""></div>
            </center>
        </div>
        <div id="footer" style="position: fixed; bottom: 0; margin-top: 0; padding-top: 0; vertical-align: top; width: 100%;  height: 40px; display:none;background-color:rgba(0,0,0,1);">
            <button type="button" class="butty saveImages" style="padding:3px;display:none;background-color:#444;margin-left:44px;">Save Images</button>
            <button class="butty showSelected" style="background-color:#888;margin-left:33px;">Show selected</button>
        </div>
    </main>
    <script>
    var angle;
    var angle2;
    var radius;
    var shape;
    var shape2;
    var offset = 0;
    var factor;

    var aangle1 = 0;
    var aangle2 = 0;
    var sangle = 0
    var aini1 = 0;
    var aini2 = 0;

    var centerx = 0;
    var centery = 0;
    var diagonal2 = 100;
    var W = 400;
    var H = 400;
    var contmore = 1
    var clickCount = 1;
    var contSaved = 0;
    var coord;
    var inpt;
    var contdiv;
    var showr, showl, reloadi, savef, inum;
    var contf = 1
    var paresBase = [-0.11, -0.12, -0.13, -0.14,-0.141, -0.15, -0.16, -0.17, 0.1, 0.4, 0.41, 0.5, 0.6, 0.7, 0.8, 0.9, 0.101, 1.1, 1.1, 1.2, 1.3, 1.5, 1.6, 1.6, 1.7, 2.1, 2.2, 3.1, 3.2, 3.21, 3.22, 3.24, 3.25, 3.3, 3.4, 3.5, 3.5, 3.51, 3.51, 3.6, 3.6, 4.1, 4.2, 4.3, 4.3, 4.4, 4.4, 4.5, 4.5, 4.51, 4.51, 4.6, 4.61, 4.62, 4.7, 4.7, 5.0, 5.1, 5.2, 5.21, 5.22, 5.3, 5.31, 5.4]
    var pares = [...paresBase]
    var polis = [4, 6, 8, 10, 12, 16, 18, 20, 32, 64]
    //pares = [...new Array(10)].map(() => 5.2);
    if(window.location.hash) {
        var n=window.location.hash.substring(1,100)
        //alert(n)
     pares = [...new Array(10)].map(() => parseFloat(n));
     console.log(n)
    } else {
      // Fragment doesn't exist
    }
   
    var pary = [...pares]
    var poly = [...polis]
    var cfoto = []
    var caddy = []
    var slices = 24;
    var img = [];
    var started = false
    var imgsize = { w: 10, h: 10, propor: 1, cursor: 40 }
    var dallimgs
    var codehtml = ''
    var canvasbill
    var dmy
    var nfoto = []
    var nShape = 1;
    var savedSucure;
    let org = 0
    var lastfoto = -1
    var idSession = ''
    let checkedTypes = [];
    const shapes = new Map();

    function selectShapes(checkedTypes, pares) {
        const selectedShapes = pares.filter(
            (par) => checkedTypes.some((type) => par.toString().startsWith(type))
        );
        return selectedShapes;
    }

    $(document).ready(function() {
        const buttonStart = $("#start");
        buttonStart.on("click", function() {
            $(".layer").hide();
            $(".otracapa").show();
            var inputImage = createFileInput(handleImg);
            inputImage.parent('imageUpload')
        });

        $(".shape").click(function(e) {
            //console.log(',' + e.target.className + ', ' + caddy.length)
            if (e.target.className != ".selectef" || e.target.className != "convert addy") {
                $(".shape").hide();
                var menu = document.getElementById("menu");
                if (menu.style.left === "0") {
                    menu.style.left = "-250px";
                }
                //$(".capadibujo").show();
                //
            }
        });




        $(".selectType").on('change', function(e) {
            const selectTypes = $('.selectType');
            checkedBoxes = selectTypes.filter(':checked');
            checkedTypes = [];
            checkedBoxes.each(function() {
                checkedTypes.push($(this).val());
            });
            pares = []
            pares = selectShapes(checkedTypes, paresBase)
            pary = [...pares]
        });

        toggleMenu()
        $(".saveImages").on("click", function() {
            saveAllImages()
        });
        $(".saveCode").on("click", function() {
            saveCode()
        });

        $(".showSelected").click(function(e) {
            savedSecure = [...cfoto]
            caddy = []
            /*cfoto.forEach(array => {
              if (Array.isArray(array)) {
                const objeto = { ...array[0] }; // Copiamos el elemento 0 de cada subarray
                caddy.push(objeto); // Agregamos el objeto copiado a objetosSeleccionados
                array.forEach(subobjeto => {
                  if (subobjeto.select === true) {
                    caddy.push(subobjeto);
                  }
                });
              }
            });
            */


            //caddy = []
            caddy.push({ ...cfoto[lastfoto][0] });

            cfoto.forEach(array => {
                if (Array.isArray(array)) {
                    array.forEach(objeto => {
                        if (objeto.select === true) {
                            const duplicado = caddy.some(obj => JSON.stringify(obj) === JSON.stringify(objeto));
                            if (duplicado) {
                                duplicado.select = false;
                            } else {
                                caddy.push(objeto);
                            }
                            //caddy.push(objeto);
                            //-->objeto.select=false
                        }
                    });
                }
            });
            //cfoto[lastfoto] = [...caddy]


            //cfoto[lastfoto] = [...caddy
            cfoto.push(caddy)
            lastfoto = cfoto.length - 1
            //console.log('lastfoto: ' + lastfoto)
            contf = 1
            codehtml = ''
            dallimgs.html('')
            //img.push(cfoto[lastfoto][0].img)
            img[img.length] = loadImage(
                cfoto[lastfoto][0].img,
                () => {
                    slices = cfoto[lastfoto][0].n
                    loop()
                },
                () => print('Image Failed to Load.'),
            );

        });
    });

    function toggleMenu() {
        var menu = document.getElementById("menu");
        if (menu.style.left === "-250px") {
            menu.style.left = "0";
        } else {
            menu.style.left = "-250px";
        }
    }

    function handleImg(file) {
        if (file.type === "image") {
            $(".otracapa").hide();
            $(".preload").show();
            $(".capadibujo").show();
            //img2 = loadImage(file.data)

            img[0] = loadImage(
                file.data,
                () => {
                    //alert('Selected file: ' + file.value);
                    //$(".preload").show();
                    idSession = makeid(50)
                    canvasbill = createCanvas(W, H);
                    iniShapes()
                    canvasbill.parent('#bill')
                    dallimgs = select('#allimgs')

                    $(".preload").hide();
                    textSize(50);
                    frameRate(12)
                    imageMode(CENTER);
                    dmy = select('#myShape')
                    $('.shape').show()
                    reini(file.data, img[0].width, img[0].height)
                },
                () => print('Image Failed to Load.'),
            );

        };
    }

    function setup() {
        createMetaTag()
        noLoop()
    }

    function draw() {
        if (lastfoto >= 0) {
            var tt = '<div style="color:#888;margin-top:100px;font-size:33px;">' + (contf) + ' ' + (cfoto[lastfoto].length - 1) + ' shapes</div>'
            $('#myShape').html(tt)
        }
        //console.log('FOTO ',contf,cfoto.length)
        if (started) {
            if (contmore == 1) {
                select('#header').show();
                select('#footer').show();
            }
            //dallimgs.html('<span style="margin-top:100px;font-size:33px;">'+contf+' '+cfoto.length-1+'</span>')
            slices = cfoto[lastfoto][contf].n
            var d = cfoto[lastfoto][contf].d
            $('.shape').show()
            drawbill(contf, W, H, slices, d)
            contf++
            if (contf >= cfoto[lastfoto].length) {
                noLoop()
                //$('.capadibujo').show()
                contf = cfoto[lastfoto].length
                poly = [...polis]
                pary = [...pares]
                codehtml += '<center><button type="button" class="convert more" id="m' + contmore + '" style="display:block;">More</button></center>'
                //codehtml+='<br><button class="convert showSelected" style="background-color:#888;margin-left:33px;">Show selected</button>'
                //codehtml +='<button type="button" class="convert saveImages" style="background-color:#444;margin-left:44px;">Save Images</button>'
                //codehtml +='<button type="button" class="convert saveCode" style="background-color:#444;margin-left:44px;">Save code</button></center>'
                //$("button").remove(".more");
                dallimgs.html(codehtml, true)
                $('#allimgs').scrollTop($('#allimgs').scrollHeight);
                $('.shape').fadeOut(1000)
                codehtml = ''
                $(".forma").on("click", function() {
                    //console.log(JSON.stringify())
                    var n = this.children[0].id
                    //console.log(n)
                    enhance(n)
                });
                $(".more").on("click", function() {
                    $('.shape').show()
                    contmore++
                    newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
                    $("button").remove(".more");
                    //$("button").remove(".saveImages");
                    //$("button").remove(".saveCode");
                    //$("button").remove(".showSelected");
                    $("#menu").css('left','-250px')
                    //toggleMenu()
                    loop()
                });

            }
        }
    }

    function drawbill(conti, w, h, slices, diagonal) {
        background(0, 0)
        clear()
        factor = 0.5
        var x = cfoto[lastfoto][conti].x;
        var y = cfoto[lastfoto][conti].y;
        var p = cfoto[lastfoto][conti].p;
        var ang = cfoto[lastfoto][conti].a;
        org = cfoto[lastfoto][conti].org;

        //var ang = 1 * random(1)
        var ns = nsides = polis[p]
        //var ns = floor(random(0, polis.length))
        //var nsides = polis[ns]
        //var nsides = polis[p]

        var rotation = 0
        //////////////////////////////////
        //var rns=floor(random(0,pares.length))
        //shapes.get(pares[rns]).apply(null,[slices,diagonal,{scl:factor,rtt:0,trx:0,try:0},ang*random(1),x,y]);
        shapes.get(slices).apply(null, [p, diagonal, { scl: factor, rtt: rotation, trx: 0, try: 0 }, ang, x, y]);

        /////////////////////////////////////
        codehtml += '<div class="forma" style="vertical-align: top;margin:0px;padding:0px;display:inline-block;width:200px;height:200px;font-size:220px;background-color:transparent;"><img id="i' + contf + '" width="200px" height="200px" src="' + shape2.canvas.toDataURL() + '"></div>'

        //nfoto[contf]=shape2.canvas.toDataURL()
        if (conti % 4 == 0) { codehtml += '<br style="height: 0;">' }

    }

    function getImageData(w, h) {
        const imgn = {
            w: w,
            h: h,
        };
        if (w >= h) {
            imgn.maxDim = w;
            imgn.minDim = h;
        } else {
            imgn.maxDim = h;
            imgn.minDim = w;
        }
        const cx = w / 2;
        const cy = h / 2;
        imgn.angle = Math.atan2(cy, cx); // Angle in radians
        imgn.semidiagonal = Math.sqrt(Math.pow(cx, 2) + Math.pow(cy, 2)); // Length from the center to the bottom right corner
        const sideLength = imgn.maxDim;
        const tlx = cx - sideLength / 2;
        const tly = cy - imgn.minDim / 2;
        const brx = cx + sideLength / 2;
        const bry = cy + imgn.minDim / 2;
        imgn.tl = {
            x: tlx,
            y: tly
        };
        imgn.br = {
            x: brx,
            y: bry
        };
        return imgn;
    }

    function reini(iimg, w, h) {
        //img=loadImage(iimg) 

        cfoto.push([{ "w": 640, "h": 963, "n": 8, "W": 300, "o": 0, "d": 640, "id": "p0a2OHWO1TXUnHfq4zQVDG5lPa1AReHkVwjj39yKGlQ7Ot6QO1", "img": "" }])

        lastfoto = cfoto.length - 1

        //console.log('lastfoto: '+lastfoto)
        slices = cfoto[lastfoto][0].n
        cfoto[lastfoto][0].img = iimg
        started = true
        codehtml = ''
        nfoto = []
        cfoto[lastfoto][0].W = W
        cfoto[lastfoto][0].w = w
        cfoto[lastfoto][0].h = h

        cfoto[lastfoto][0].id = idSession

        caddy = [...cfoto[lastfoto]]

        //cfoto[0].push({"org":0,"x":(w/2),"y":(h/2),"n":0.4,"d":mvh,"p":64,"a":0.1,"select":true})
        var imgn = getImageData(w, h)
        cfoto[0].push({ "org": 0, "x": (w / 2), "y": (h / 2), "n": 0.41, "d": imgn.semidiagonal, "p": 64, "a": imgn.angle, "select": true })
        nfoto = []
        contf = 1
        nShape = 1;
        dallimgs.html(codehtml)
        $('.shape').show()
        newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
        loop();
    }


    function info(d) {

    }

    function fillRandom(values, n) {
        const result = [];
        for (let i = 0; i < n; i++) {
            const randomIndex = Math.floor(Math.random() * values.length);
            result.push(values[randomIndex]);
        }
        return result;
    }
    //var actualn=0
    var imgN

    function enhance(n) {
        //$('.capadibujo').hide()
        var dla = select('.shape')
        nShape = n.replace(/^\D+/g, '');
        //alert(nn)
        //n=2
        //actualn=n
        dla.show()
        var dmy = select('#myShape')
        imgN = select('#' + n + '').attribute('src');
        //var code = '<img class=".selectef" src="' + imgN + '" width="' + cfoto[lastfoto][0].W + 'px">';
        var code = '<img class=".selectef" src="' + imgN + '" width="' + 400 + 'px">';
        code += '<br><span style="color:#ddd;font-size:12px;">' + JSON.stringify(cfoto[lastfoto][nShape]) + '</span>';
        code += '<br><button class="convert downy" style="background-color:#666;">Download</button>'
        code += '<button class="convert usy" style="background-color:#a6a;">Use</button>'
        code += '<button class="convert simy" style="background-color:#a66;">Similar</button>'
        code += '<button class="convert addy" style="background-color:#aaa;">Add</button>'
        dmy.html(code)
        $(".downy").click(function(e) {
            saveImage()
        });
        $(".addy").click(function(e) {
            //console.log(JSON.stringify(cfoto[lastfoto][nShape]))
            cfoto[lastfoto][nShape].select = true
            caddy.push(cfoto[lastfoto][nShape])


        });
        $(".usy").click(function(e) {
            caddy.push(cfoto[lastfoto][nShape])
            img[img.length] = loadImage(imgN, () => {
                //reini(imgN, cfoto[lastfoto][0].W, cfoto[lastfoto][0].W)
                var rry = [cfoto[lastfoto][nShape].n, cfoto[lastfoto][nShape].n]
                var lly = [cfoto[lastfoto][nShape].p, cfoto[lastfoto][nShape].p]
                cfoto[lastfoto][nShape].select = true
                cfoto.push([...cfoto[lastfoto]])
                lastfoto = cfoto.length - 1
                cfoto[lastfoto][0].img = imgN
                cfoto[lastfoto][0].w = img[lastfoto].width
                cfoto[lastfoto][0].h = img[lastfoto].height
                pary = fillRandom(rry, 10)
                poly = fillRandom(lly, 10)
                contmore++
                newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
                $("button").remove(".more");
                //$('.shape').show()
                loop()
            });

        });
        $(".simy").click(function(e) {
            var rry = [cfoto[lastfoto][nShape].n, cfoto[lastfoto][nShape].n]
            var lly = [cfoto[lastfoto][nShape].p, cfoto[lastfoto][nShape].p]
            pary = fillRandom(rry, 10)
            poly = fillRandom(lly, 10)
            cfoto[lastfoto][nShape].select = true
            //lastfoto=cfoto.length-1
            //$('.shape').show()
            contmore++
            newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
            $("button").remove(".more");
            loop()
        });
    }

    function saveImage() {

        var link = document.createElement("a");
        link.id = 'thisi';
        link.download = makeid(8) + '.png'
        link.href = imgN;
        link.click();
    }

    var savi = null

    function saveAllImages() {
        var images = document.getElementsByTagName('img');
        var srcList = [];
        var i = 0;
        var nimages = images.length
        if (nimages < 7) {
            var savi = setInterval(function() {
                if (i < nimages) {
                    srcList.push(images[i].src);
                    var link = document.createElement("a");
                    link.id = i;
                    link.download = makeid(8) + '.png'
                    link.href = images[i].src;
                    link.click();
                    i++;
                } else {
                    clearInterval(savi)
                    savi = null
                }
            }, 1500);
        }
    }

    function saveCode() {
        var nww = window.open('', 'newh')
        nww.document.write(JSON.stringify(cfoto))
    }

    function makeid(length) {
        var result = '';
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return result;
    }



    function newRandco(w, h, rows, columns, npair) {
        var pm = min(w, h)
        var margin = random(10, 50)
        var cont = 1
        //cfoto.splice(1, cfoto.length);
        let pr
        let dr
        let x, y, pxy, ang
        //var npair=0
        //var imglf=img[lastfoto]
        for (let row = 0; row < rows; row++) {
            for (let column = 0; column < columns; column++) {
                //let x = column * width / columns - margin;
                //let y = row * height / rows - margin;
                //if (x <= 0) {
                x = parseInt(Math.random() * (cfoto[lastfoto][0].w - margin))
                //}
                //if (y <= 0) {
                y = parseInt(Math.random() * (cfoto[lastfoto][0].h - margin))
                //}
                pxy = min(w - x, h - y)
                dr = random(margin, w - pxy)
                let fxy = rectToSquare({ w: w, h: h }, x, y, dr)

                pr = pary[floor(random(0, pary.length))]
                pl = poly[floor(random(0, poly.length))]
                ang = random(0.00001, 1)
                cfoto[lastfoto].push({
                    org: lastfoto,
                    x: fxy.x,
                    y: fxy.y,
                    n: pr,
                    d: fxy.w,
                    p: pl,
                    a: ang,
                    select: false
                });
                cont++
                //if(cont===floor(rows*columns/2)){npair++}
            }
        }
    }

    function rectToSquare(wh, x, y, d) {
        const s = {};
        // Adjust coordinates if they exceed the rectangle boundaries
        if (x < d / 2) {
            x = d / 2;
        } else if (x > wh.w - d / 2) {
            x = wh.w - d / 2;
        }
        if (y < d / 2) {
            y = d / 2;
        } else if (y > wh.h - d / 2) {
            y = wh.h - d / 2;
        }
        // Calculate the two points of the square
        s[0] = { x: x - d / 2, y: y - d / 2 };
        s[1] = { x: x + d / 2, y: y + d / 2 };
        return {
            tl: s[0],
            br: s[1],
            w: d,
            x: x,
            y: y,
        };
    }

    function squareToRect(wh, x, y, l, w) {
        const s = {};
        // Verificar si el ancho es mayor que la altura
        if (wh.w > wh.h) {
            if (l > wh.h) {
                l = wh.h; // Ajustar la longitud a la altura máxima
            }
            if (w > wh.h) {
                w = wh.h; // Ajustar el ancho a la altura máxima
            }
        } else {
            if (l > wh.w) {
                l = wh.w; // Ajustar la longitud al ancho máximo
            }
            if (w > wh.w) {
                w = wh.w; // Ajustar el ancho al ancho máximo
            }
        }
        // Ajustar las coordenadas si exceden los límites del rectángulo
        if (x < l / 2) {
            x = l / 2;
        } else if (x > wh.w - l / 2) {
            x = wh.w - l / 2;
        }
        if (y < w / 2) {
            y = w / 2;
        } else if (y > wh.h - w / 2) {
            y = wh.h - w / 2;
        }
        // Calcular los dos puntos del rectángulo
        s[0] = { x: x - l / 2, y: y - w / 2 };
        s[1] = { x: x + l / 2, y: y + w / 2 };
        return {
            tl: s[0],
            br: s[1],
            l: l,
            w: w,
            x: x,
            y: y,
        };
    }

    function createMetaTag() {
        //https://openprocess4.org/sketch/790331

        //Mobile Devices by Oren Shoham

        let meta = createElement("meta");

        meta.attribute("name", "viewport");

        meta.attribute(
            "content",

            "user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width,height=device-height"
        );

        let head = select("head");

        meta.parent(head);
    }


    /////////////////////////
    // shapes.js
    ////////////////////////
    //const shapes = new Map();
    //iniShapes()

    function iniShapes() {
        shapes.set(-0.11, (n, d, tr, an, x, y) => {
            var title = "simply gradient V rect to down black";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt = img[org].get(x, y)
            var geto = color(red(gt), green(gt), blue(gt))
            var geta = color(0, 0, 0)
            var geti;
            cmod = 0
            var mod = 1 / n

            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * modi, l, modi)
                cmod += mod

            }
        });
        shapes.set(-0.12, (n, d, tr, an, x, y) => {
            var title = "simply gradient V rect to colorA to colorB";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
             if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var gt2 = img[org].get(x + d, y + d)
            var geto = color(red(gt1), green(gt1), blue(gt1))
            var geta = color(red(gt2), green(gt2), blue(gt2))
            var geti;

            cmod = 0
            var mod = 1 / n

            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                 if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * modi, l, modi)
                cmod += mod

            }
        });
        shapes.set(-0.13, (n, d, tr, an, x, y) => {
            var title = "simply V color list";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var mod = l / n
            var geti
            for (let a = 0; a < n; a++) {
                geti = img[org].get(x, y + 1 * a)
                  if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * mod, l, mod)
            }
        });
        shapes.set(-0.14, (n, d, tr, an, x, y) => {
            var title = "palette random color table in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geti
            shape2.strokeWeight(4)
            var mod = l / n
            for (let b = 0; b < n; b++) {
                for (let a = 0; a < n; a++) {
                    geti = img[org].get(x + 4 * a, y + 4 * b)
                    if(floor(d)%2==0){
                        shape2.stroke(0)
                    }else{
                        shape2.stroke(geti)
                    }
                    shape2.fill(geti)
                    shape2.rect(a * mod, b * mod, mod, mod)
                }
            }

        });
         shapes.set(-0.141, (n, d, tr, an, x, y) => {
            var title = "palette random color table in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geta= img[org].get(x , y)
            var gete= img[org].get(x + 12 , y + 12 )
            shape2.strokeWeight(4)
            var mod = l / n
            var npar=0
            for (let b = 0; b < n; b++) {
                if(b%2==0){npar=0}else{npar=1}
                for (let a = 0; a < n; a++) {
                  
                    
                    if(a%2==npar){
                        shape2.fill(geta)
                        shape2.stroke(geta)
                    }else{
                        shape2.stroke(gete)
                        shape2.fill(gete)
                    }
                    
                    shape2.rect(a * mod, b * mod, mod, mod)
                }
            }

        });
        shapes.set(-0.15, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect to colorA to colorB";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var gt2 = img[org].get(x + d, y + d)
            var geto = color(red(gt1), green(gt1), blue(gt1))
            var geta = color(red(gt2), green(gt2), blue(gt2))
            var geti;
            cmod = 0
            var mod = 1 / n
            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                if(floor(d)%2==0){
                        shape2.stroke(0)
                    }else{
                        shape2.stroke(geti)
                    }
                shape2.fill(geti)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
            }
        });
        shapes.set(-0.16, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect to colorA to black";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
           if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var geta = color(red(gt1), green(gt1), blue(gt1))
            var gete = color(0, 0, 0)
            var getu;
            cmod = 0
            var mod = 1 / n
            for (let a = 0; a < n; a++) {
                getu = lerpColor(geta, gete, cmod);
                 if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
            }
        });
        shapes.set(-0.17, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect black to colorA to white";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
             if(floor(d)%2==0){
                shape2.strokeWeight(4)
            }else{
                shape2.strokeWeight(1)
            }
            var gt1 = img[org].get(x, y)
            var cmod = 0
            var geta = color(0, 0, 0)
            var gete = color(red(gt1), green(gt1), blue(gt1))
            var geti = color(255, 255, 255)
            var getu = lerpColor(geta, gete, cmod);
            var modi = l / (n * 2 + 1)
            var mod = 1 / n
            for (let a = 0; a < n; a++) {

                if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
                getu = lerpColor(geta, gete, cmod);
            }
            a = n
             if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(getu)
                }
            shape2.fill(gete)
            shape2.rect(a * modi, 0, modi, l)
            cmod = mod
            a += 1
            for (let b = a; b < (n * 2 + 1); b++) {
                getu = lerpColor(gete, geti, cmod);
                 if(floor(d)%2==0){
                    shape2.stroke(0)
                }else{
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(b * modi, 0, modi, l)
                cmod += mod
            }

        });
        shapes.set(0.1, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geti = img[org].get(x, y)
            shape2.noStroke()
            shape2.fill(geti)
            shape2.rect(0, 0, l, l)

        });
        shapes.set(0.4, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var cutname = 0;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            cutSquare(org, x, y, cutname, l, d);
            image(shape2, 0, 0);
            pop();
        });
        shapes.set(0.41, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a rectangle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var cutname = 0.1;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, cutname, l, d, an);
            image(shape2, 0, 0);
            pop();
        });
        shapes.set(0.5, (n, d, tr, an, x, y) => {
            var title = "rect pattern from cutted image";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var limit = (n * 1) + 1;
            var rade = l / n;
            var dx = 0;
            var dy = 0;
            let img2 = img[org].get(x, y, rade, rade);
            for (var a = 0; a < limit; a++) {
                for (var b = 0; b < limit; b++) {
                    dx = rade * a
                    dy = rade * b
                    shape2.image(img2, dx, dy);
                }
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(0.6, (n, d, tr, an, x, y) => {
            var title = "mask image with circle";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(0.61, (n, d, tr, an, x, y) => {
            var title = "mask image with circle radius";
            var l = min(width, height);
            //shape2.background(200, 50, 100);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.smooth();
            var dx = l * 2 / n
            var cx = map(x, 0, img[0].width, 0, l - dx)
            var cy = map(y, 0, img[0].height, 0, l - dx)
            shape2.push()
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(-l / 2 + dx / 2, -l / 2 + dx / 2, dx, dx)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop()
            //shape2
        });
        shapes.set(0.7, (n, d, tr, an, x, y) => {
            var title = "Vgradient 2 random colors from image";
            var c1 = img[org].get(x, y)
            var c2 = img[org].get(x + d, y + d)
            shape2 = createGraphics(width, height, WEBGL);
            shape2.beginShape(QUAD_STRIP);
            shape2.fill(c1);
            shape2.vertex(-width / 2, -height / 2);
            shape2.vertex(width / 2, -height / 2);
            shape2.fill(c2);
            shape2.vertex(-width / 2, height / 2);
            shape2.vertex(width / 2, height / 2);
            shape2.endShape();
        });
        shapes.set(0.71, (n, d, tr, an, x, y) => {
            var title = "Vgradient 2 random colors from image in circle";
            var l = min(width, height);
            var c1 = img[org].get(x, y)
            var c2 = img[org].get(x + d, y + d)
            shape2 = createGraphics(width, height, WEBGL);
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
            shape2.beginShape(QUAD_STRIP);
            shape2.fill(c1);
            shape2.vertex(-width / 2, -height / 2);
            shape2.vertex(width / 2, -height / 2);
            shape2.fill(c2);
            shape2.vertex(-width / 2, height / 2);
            shape2.vertex(width / 2, height / 2);
            shape2.endShape();
        });
        shapes.set(0.8, (n, d, tr, an, x, y) => {
            var title = "mask image with disk";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.noFill()
                shape2.strokeWeight(l / 4)
                shape2.stroke(0)
                shape2.ellipse(0, 0, l - l / 4, l - l / 4)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(0.9, (n, d, tr, an, x, y) => {
            var title = "mask image with star";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            let vert = getStarN(n, l * 0.5, -4, -30)

            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.beginShape();
                shape2.fill(255);
                for (let a = 0; a < vert.length; a++) {
                    shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
                }
                shape2.endShape();
            });

            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });

    shapes.set(0.101, (n, d, tr, an, x, y) => {
            var title = "mask circle image life flower";
            var l = min(width, height);
            //shape2.background(200, 50, 100);
              shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
             let geta= shape2.get(0,0,l,l)
             shape2.clear()
              shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
          shape2.image(geta,-l/2,-l/2)
            shape2.pop()
            //shape2
        });

        shapes.set(1.1, (n, d, tr, an, x, y) => {
            var title = "spiral points";
            var l = min(width, height);
            shape2 = createGraphics(l * 2, l * 2);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var numVertices = 1800;
            var angle = 0.30;
            var offset = width * 1;
            var scalar = 6;
            var speed = 0.3;
            if (d > 0.01) {
                scalar = an * n * 2
                speed = 180 / d;
            }
            var direction = 1
            if (int(d % 2) == 0) { direction = -1 }
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = 0;
            var dy = 0;
            while (dx < l * 2 * sqrt(2) && dy < l * 2 * sqrt(2)) {
                coli = img[org].get(contx, conty)
                dx = offset + cos(angle) * scalar;
                dy = offset + sin(angle) * scalar;
                dcenter = dist(dx, dy, offset, offset)
                var rade = map(dcenter, 0, width, 8, 55)
                shape2.fill(coli)
                shape2.stroke(coli)
                //cutShape(org, dx, dy, 1, rade, d, an = 1)
                shape2.ellipse(dx, dy, rade, rade);
                if (direction == -1) { angle -= speed; } else {
                    angle += speed;
                }
                scalar += speed;
                contx += 1
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(1.2, (n, d, tr, an, x, y) => {
            var title = "concentrics circles";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = l * 2 * sqrt(2);
            var dy = l * 2 * sqrt(2);
            while (dx > 0 && dy > 0) {
                coli = img[org].get(contx, conty)
                shape2.fill(coli)
                shape2.stroke(coli)
                shape2.ellipse(l / 2, l / 2, dx, dy);
                dx = dx - 1;
                dy = dy - 1;
                contx += 1
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            //image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(1.3, (n, d, tr, an, x, y) => {
            var title = "concentrics circles with points";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = l * 1 * sqrt(2);
            var dy = l * 1 * sqrt(2);
            var mod = TWO_PI / n
            var mode = 8
            var px = 0
            var py = 0
            var ann = 0
            var dw = 30
            while (dx > 0 && dy > 0) {

                //shape2.ellipse(l/2,l/2, dx, dy);
                //ann+=an
                ann = 0
                dw = dist(dx, dy, 0, 0)
                coli = img[org].get(contx, conty)
                shape2.fill(coli)
                shape2.stroke(coli)
                for (var a = 0; a < n; a++) {

                    px = l / 2 + dx * cos(ann)
                    py = l / 2 + dy * sin(ann)
                    shape2.ellipse(px, py, dw / 2, dw / 2);
                    contx += 1

                    ann += mod
                }
                dx = dx - 8;
                dy = dy - 8;
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            //image(shape2, 0, 0);
            shape2.pop();
        });





        shapes.set(1.5, (n, d, tr, an, x, y) => {
            var title = "rect pattern points";
            var l = min(width, height);
            const wh = { w: img[org].width, h: img[org].height };

            var nn = 0;
            var nnn = floor(d) % 2
            if (nnn == 0) { nn = 16 }
            if (nnn == 1) { nn = 32 }
            //if(nnn==2){nn=32}

            const t = rectToSquare(wh, x, y, d)
            //console.log(t)
            var rade = l / nn;
            var pade = t.w / nn;
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            var cx = 0
            var cy = 0
            var geti = img[org].get(t.tl.x, t.tl.y, t.w, t.w)


            for (var b = 0; b < l; b += rade) {
                for (var a = 0; a < l; a += rade) {
                    var col = geti.get(cx, cy)
                    var light = lightness(col);
                    //console.log('light',light)
                    var radius = map(light, 0, 255, 3, pade * 1);
                    //shape2.fill(0);
                    //shape2.ellipse(a, b, 40);
                    shape2.fill(col);
                    shape2.ellipse(a, b, radius);
                    cx += pade
                }
                cx = 0
                cy += pade
            }
            /*
        shape2.fill(199,0,0)
            shape2.ellipse(0,0,100,100)
            shape2.fill(199,100,0)
            shape2.ellipse(width,height,100,100)
*/
            image(shape2, 0, 0);
        });

        shapes.set(1.6, (n, d, tr, an, x, y) => {
            var title = "shape along curve";
            var l = min(width, height);
            shapes.get(0.61).apply(null, [n * 2, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            shape2.clear()
            var wx = map(x, 0, img[org].width, 0, l)
            var wy = map(y, 0, img[org].height, 0, l)
            let p1 = { x: -l / 2, y: -l / 2 }
            let p2 = { x: wx, y: -wy }
            let p3 = { x: -wx, y: wy }
            let p4 = { x: l / 2, y: l / 2 }
            for (let i = 0; i < 100; i++) {
                let pt = bez(i / 100, p1, p2, p3, p4);
                let dx = pt.x - pr.x;
                let dy = pt.y - pr.y;
                if (i % 2 === 0 && i !== 0) {
                    let th = atan2(pt.y + dx * 50 - pt.y, pt.x - dy * 50 - pt.x)
                    shape2.noStroke()
                    shape2.push()
                    shape2.translate(pt.x, pt.y)
                    shape2.rotate(th)
                    shape2.translate(0, 0)
                    shape2.fill(255, 200, 0)
                    shape2.texture(img2)
                    shape2.rect(0, 0, l, l)
                    //shape2.image(img2,0,0)
                    shape2.pop()
                    //console.log(i)
                }
                pr.x = pt.x;
                pr.y = pt.y;
            }
        });

        shapes.set(1.7, (n, d, tr, an, x, y) => {
            var title = "H cenefa";
            var l = min(width, height);
            shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            let v1=l/n
            let v2=v1/2
            shape2.clear()
            img2.resize(v1,v1)
            shape2.push()
            shape2.translate(0,-v2)
            shape2.image(img2,0,0)
            for(var a=0;a<n/2;a++){
            shape2.translate(-v1,0)
            shape2.image(img2,0,0)
            }
            shape2.pop()
            
            shape2.push()
            shape2.translate(v1,-v2)
            shape2.image(img2,0,0)
           for(a=0;a<(n/2)-1;a++){
                shape2.translate(v1,0)
                shape2.image(img2,0,0)
            }
            shape2.pop()

        });
        
        shapes.set(2.1, (n, d, tr, an, x, y) => {
            var title = "Sun and floor";
            var l = min(width, height);
            shapes.get(3.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            shape2.image(geta, -l / 2, -l / 2)
            shape2.push()
            shape2.translate(0, l / 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
        });

        shapes.set(2.11, (n, d, tr, an, x, y) => {
            var title = "Sun and floor -  sketch";
            var l = min(width, height);
            shapes.get(3.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()

            const vert = getPlaneMidSide(l * 2, l * 8)
            shape2 = createGraphics(l, l, WEBGL);
            shape2.image(geta, -l / 2, -l / 2)
            shape2.push()
            shape2.translate(0, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            //shape2.texture(gete)
            //pe2.translate(0,l/2)
            //shape2.image(gete,-l/2,-l/2)

            shape2.pop()
        });

        shapes.set(2.2, (n, d, tr, an, x, y) => {
            var title = "mask image with noise";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);

            if (floor(d) % 2 == 0) {
                cutSquare(org, x, y, 0, l, d / 2);
                shape2.tint(100, 150)
            } else {
                let giti = img[org].get(x, y)
                fill(giti)
                rect(-l / 2, -l / 2, l, l)
            }
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.stroke(0);
                shape2.fill(0);
                shape2.beginShape()
                shape2.vertex(-l / 2, l / 2)

                for (let xi = -l / 2; xi < l / 2; xi++) {
                    let noiseOffset = n / 100;
                    let noiseVal = noise(noiseOffset + xi / 100);
                    shape2.vertex(xi, noiseVal * 100 - 100);
                }
                shape2.vertex(l / 2, l / 2)
                shape2.endShape()
            });

            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(3.1, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            var cutname = 1;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 4 + tr.trx, height * 0 / 4 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            shape2 - cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.2, (n, d, tr, an, x, y) => {
            var title = "symmetry regular triangle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            var cutname = 2;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();
            shape2.push();
            shape2.rotate(HALF_PI + HALF_PI / 3);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();
            shape2.push();
            shape2.rotate(-HALF_PI - HALF_PI / 3);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.21, (n, d, tr, an, x, y) => {
            var title = "pattern triangle";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            shapes.get(3.2).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shape2.clear()
            shape2.image(geta, -l / 2, -l / 2, l, l)


            shape2.push()
            shape2.rotate(PI)
            ax = l / 2 * cos(PI / 6)
            ay = l / 2 * sin(PI / 6)
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 2, -l / 2, l, l)
            shape2.pop()

            shape2.push()
            shape2.rotate(PI)
            ax = l / 2 * cos(PI / 6)
            ay = l / 2 * sin(PI / 6)
            shape2.translate(-ax, ay)
            shape2.image(geta, -l / 2, -l / 2, l, l)
            shape2.pop()


            var ssidet = l / 2 - sidet
            var icu = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.beginClip()
            //shape2.rect(-(l/2)+l/16,-l/2,(l)-l/8,l)
            shape2.rect(-(l / 2) + ssidet, -l / 2, sidet * 2, l)
            shape2.endClip()
            shape2.image(icu, -l / 2, -l / 2)

        });


        shapes.set(3.22, (n, d, tr, an, x, y) => {
            var title = "vertical symmetry from triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shapes.get(3.21).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = sidet;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)

            ax = -sidet * 2;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            shape2.pop()

            shape2.push()
            shape2.scale(1, -1)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = sidet;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = -sidet * 2;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            shape2.pop()
            if (floor(d) % 2 == 0) {
                var gete = shape2.get(0, 0, l, l)
                shape2.clear()
                shape2.image(gete, -l / 2, -l / 2)
                shape2.push()
                ax = 0;
                ay = l - (l / 4)
                shape2.translate(ax, ay)
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
                shape2.push()
                ax = 0;
                ay = -l + (l / 4)
                shape2.translate(ax, ay)
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
            }
        });

    shapes.set(3.23, (n, d, tr, an, x, y) => {
            var title = "vertical symmetry from triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shapes.get(3.22).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()
           
             if(floor(d)%2==0){
                shape2.image(geta, -l / 2, -l/2)
            }else{
                shape2.image(geta, -l / 2, -l/2, l, l)
            }
            shape2.pop()
        });
      shapes.set(3.24, (n, d, tr, an, x, y) => {
            var title = "rotated triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2.1 / sqrt(3)) / 2
            //var sideh = sidet * sqrt(3) /2
            var sideh = (l / 2.5)
            //shape2.imageMode(CENTER); 
            var dd=0
            if(floor(d)%2==0){dd=d+1}else{dd=d}
            shapes.get(3.2).apply(null, [n, dd, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var si1=(sqrt(3)/2)
            var si2=(l/4)*si1
            var pro1=(2/sqrt(3))*1
            var pro2=(l/4)*pro1
            var pro3=pro2*0.5
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            geta.resize(l/3,l/3)

          shape2.push()

             shape2.rotate(PI/6)  
            for(var a=0;a<6;a++){
            shape2.rotate(PI/3)  
            shape2.push() 
             shape2.translate((-l/6),0)
             shape2.image(geta, 0,0) 
             shape2.pop() 
         }
            shape2.pop() 

             var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push() 
            for(var a=0;a<6;a++){ 
                shape2.push() 
                if(a%2==0){
                    shape2.translate(0,pro2)
                }
                if(a%2==1){
                    shape2.translate(0,pro2*2)
                }  
                if(a%3==2){
                    //shape2.translate(0,pro2*4)
                }   
            shape2.image(gete, -l/2,-l/2) 
            shape2.pop() 
            shape2.rotate(TWO_PI/6)
            }
            shape2.pop() 

        
           shape2.push() 
           shape2.translate((l/6)*1.5,pro2*2.5)
            shape2.image(gete, -l/2,-l/2) 
            shape2.pop() 
             shape2.push() 
            shape2.translate(-(l/6)*1.5,pro2*2.5)
            shape2.image(gete, -l/2,-l/2) 
            shape2.pop() 
             shape2.push() 
            shape2.translate(-(l/6)*3,-pro2*2)
            shape2.image(gete, -l/2,-l/2) 
            shape2.pop() 
            shape2.push() 
            shape2.translate((l/6)*3,-pro2*2)
            shape2.image(gete, -l/2,-l/2) 
            shape2.pop() 
            
           
    //shape2.ellipse(0,0,9,9) 

        });
    
 shapes.set(3.25, (n, d, tr, an, x, y) => {
            var title = "H triangle pattern";
            var l = min(width, height);
            shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            n=2
            let v1=l/n
            let v2=v1/2
            shape2.clear()
            img2.resize(v1,v1)
            shape2.push()
            shape2.translate(0,-v2)
            shape2.image(img2,0,0)
            for(var a=0;a<n/2;a++){
            shape2.translate(-v1,0)
            shape2.image(img2,0,0)
            }
            shape2.pop()
            
            shape2.push()
            shape2.translate(v1,-v2)
            shape2.image(img2,0,0)
           for(a=0;a<(n/2)-1;a++){
                shape2.translate(v1,0)
                shape2.image(img2,0,0)
            }
            shape2.pop()


            shape2.push()
            shape2.translate(-v1/4,-v1-v2)
            shape2.image(img2,0,0)
            shape2.translate(-v1,0)
            shape2.image(img2,0,0)
             shape2.translate(v1*2,0)
            shape2.image(img2,0,0)
            shape2.pop()

            shape2.push()
            shape2.translate(-v1/4,v2)
            shape2.image(img2,0,0)
            shape2.translate(-v1,0)
            shape2.image(img2,0,0)
             shape2.translate(v1*2,0)
            shape2.image(img2,0,0)
            shape2.pop()

            
        });

        shapes.set(3.3, (n, d, tr, an, x, y) => {
            var title = "symmetry arrow from regular triangle aperture";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var x = 33; //random(width);
            var y = 33 + random(0, 25); //random(height);
            var g = HALF_PI;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, 4, l, d, an);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, 4, l, d, an);

            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.4, (n, d, tr, an, x, y) => {
            var title = "symmetry from isosceles triangle aperture";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, 5, l, d, an);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, 5, l, d, an);

            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.5, (n, d, tr, an, x, y) => {
            var title = "sector circle and repeat n times with symm";
            var l = min(width, height);
            shape2 = createGraphics(l * 1, l * 1, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();

            //shape2.scale(tr.scl, tr.scl);
            shape2.scale(0.5, 0.5);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);


            //shape2.translate(450,450)
            var ang = TWO_PI / n;
            for (var a = 0; a < floor(n / 2); a++) {
                shape2.rotate(ang * 2);
                shape2.push();
                cutTriangle(org, x, y, 6, l, d, ang);
                shape2.scale(-1, 1);
                shape2.rotate(PI - ang * 2);
                cutTriangle(org, x, y, 6, l, d, ang);
                shape2.pop();
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.51, (n, d, tr, an, x, y) => {
            var title = "sector circle and repeat n times with symm overflow";
            var l = min(width, height);
            shape2 = createGraphics(l * 1, l * 1, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();

            //shape2.scale(tr.scl, tr.scl);
            shape2.scale(0.5, 0.5);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);


            //shape2.translate(450,450)
            var ang = TWO_PI / n;
            for (var a = 0; a < floor(n / 2); a++) {
                shape2.rotate(ang * 2);
                shape2.push();
                cutTriangle(org, x, y, 6.1, l, d, ang);
                shape2.scale(-1, 1);
                shape2.rotate(PI - ang * 2);
                cutTriangle(org, x, y, 6.1, l, d, ang);
                shape2.pop();
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.6, (n, d, tr, an, x, y) => {
            var title = "symmetry triangles in circle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt - HALF_PI);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = TWO_PI / n;
            var dx, dy
            var ofsset = 49
            var scalar = l
            //var angi=ang*2
            var angi = TWO_PI / n
            for (var a = 0; a < n; a++) {
                shape2.push()
                cutTriangle(org, x, y, 10, scalar, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutTriangle(org, x, y, 10, scalar, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            shape2.pop();
            image(shape2, 0, 0);
        });


        /////////////////

        shapes.set(4.1, (n, d, tr, an, x, y) => {
            var title = "square sym";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, 1, l, d, null)
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 1, l, d, null)
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(4.2, (n, d, tr, an, x, y) => {
            var title = "square sym";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var d2 = random(height / 2);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, 2, l, d, d2)
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 2, l, d, d2)
            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.3, (n, d, tr, an, x, y) => {
            var title = "diamond sector circular, star";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = TWO_PI / n;
            for (var a = 0; a < n; a++) {
                shape2.push();
                cutTriangle(org, x, y, 7, l, d, ang + (ang * 0));
                shape2.scale(-1, 1);
                shape2.rotate(PI - (ang * 2) * 1);
                cutTriangle(org, x, y, 7, l, d, ang + (ang * 0));
                shape2.pop();
                shape2.rotate(ang * 2);
            }
            //shape2.image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.4, (n, d, tr, an, x, y) => {
            var title = "grid on square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, -1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.5, (n, d, tr, an, x, y) => {
            var title = "2 triangles in quart square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.textureWrap(MIRROR);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            var td = l / 2

            shape2.push()
            shape2.translate(-td, -td)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            //shape2.rotate(-ang * 1);
            //shape2.scale(-1, -1);0

            shape2.push()
            shape2.translate(td * 1, td * 1)
            shape2.scale(-1, -1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            shape2.push()

            shape2.translate(-td, td)
            shape2.scale(1, -1)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            shape2.push()
            shape2.translate(td, -td)
            shape2.scale(-1, 1)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(4.51, (n, d, tr, an, x, y) => {
            var l = min(width, height);
            shapes.get(4.5).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    //console.log('ab:', xy, a, b)
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();
        });

        shapes.set(4.6, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var angi = TWO_PI / n;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var longr = l

            for (var a = 0; a < n; a++) {
                shape2.push()
                cutSquare(org, x, y, 4, longr, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutSquare(org, x, y, 4, longr, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            pop();
            image(shape2, 0, 0);
        });
        shapes.set(4.61, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt - HALF_PI);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            var longr = l
            var angi = TWO_PI / n;
            for (var a = 0; a < n; a++) {
                shape2.push()
                cutSquare(org, x, y, 5, longr, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutSquare(org, x, y, 5, longr, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            pop();
            image(shape2, 0, 0);
        });
        shapes.set(4.62, (n, d, tr, an, x, y) => {
            var title = "concentric rings";
            var l = min(width, height);
            /*   shape2 = createGraphics(l, l, WEBGL);
               push();
               shape2.scale(tr.scl, tr.scl);
               shape2.rotate(tr.rtt - HALF_PI);
               translate(width / 2 + tr.trx, height / 2 + tr.try);
               var longr = l
               var angi = TWO_PI / n;
               for (var a = 0; a < n; a++) {
                   shape2.push()
                   cutSquare(org, x, y, 5, longr, d, angi);
                   shape2.scale(-1, 1);
                   shape2.rotate(PI - (angi * 2));
                   cutSquare(org, x, y, 5, longr, d, angi);
                   shape2.pop();
                   shape2.rotate(angi * 2);
               }
               pop();
               */
            //image(shape2, 0, 0);
            shapes.get(4.61).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            //shapes.get(4.61).apply(null, [n, d+10, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x+10, y+10]); 

            //var geti = shape2.get(0, 0,l, l)
            //shape2.clear()  
            ///////////////////
            //var sz = 1
            //sz = floor(d) % 5 + 2
            //shape2.image(geta,-l / 2, -l / 2 , l / sz, l / sz)
            var n1 = 1;
            var n2 = 2
            /*shape2.image(geta,-l*2 , -l*2, l*4,l*4 )
            shape2.image(geta,-l , -l, l*2,l*2 )
            shape2.image(geta,-l/2 , -l/2, l,l )
            shape2.image(geta,-l/4 , -l/4, l/2,l/2 )
            shape2.image(geta,-l/8 , -l/8, l/4,l/4 )
            */
            shape2.image(geta, -l * 2, -l * 2, l * 4, l * 4)
            let roti = TWO_PI / n;
            shape2.push()
            for (var a = 1; a < 7; a++) {
                //if(a%2==0){
                shape2.rotate(roti)
                shape2.image(geta, -l * (1 / n1), -l * (1 / n1), l * n2, l * n2)
                //}else{
                //shape2.image(geti,-l*(1/n1), -l*(1/n1), l*n2,l*n2 )
                //}
                n1 = n1 * 2
                n2 = n2 / 2
            }
            shape2.pop()
        });
        shapes.set(4.7, (n, d, tr, an, x, y) => {
            var title = "grid on square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, -1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            image(shape2, 0, 0);
            shape2.pop();
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    //console.log('ab:', xy, a, b)
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();

        });

        shapes.set(4.71, (n, d, tr, an, x, y) => {
            var title = 'square patttern'
            var l = min(width, height);
            shapes.get(4.7).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    //console.log('ab:', xy, a, b)
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();
        });
        shapes.set(5.0, (n, d, tr, an, x, y) => {
            var title = 'tetrahedrom spheres color'
            var l = min(width, height);
            let coln
            let vert = getTetraVert(l * sqrt(2)) //2*sqrt(2)
            shape2 = createGraphics(l, l, WEBGL);

            coln = img[org].get(x, y)
            //shape2.ambientLight(60, 60, 60);

            shape2.specularMaterial(red(coln) * 0.1);

            shape2.pointLight(red(coln), green(coln), blue(coln), l * 118, -l * 122, l * 118);
            shape2.directionalLight(0, green(coln), blue(coln), 0, 0, -l * 100)


            for (var a = 0; a < 12; a++) {
                shape2.push()
                shape2.translate(0, 0, -l * 2 * a + 1)
                shape2.rotate(an + a)

                for (let i = 0; i < vert.length; i++) {
                    var colx = x + d * cos(an * i)
                    coln = img[org].get(colx, y + i + a)
                    shape2.noStroke()
                    shape2.push()
                    shape2.ambientMaterial(red(coln), green(coln), blue(coln));
                    shape2.emissiveMaterial(red(coln) * 0.1, green(coln) * 0.1, blue(coln) * 0.1)
                    shape2.shininess(lightness(coln));
                    shape2.translate(vert[i].x, vert[i].y, vert[i].z)
                    shape2.fill(coln)
                    shape2.rotate(an * n + i)
                    shape2.sphere(l * 2 / n)
                    //shape2.ellipse(0,0, l,l)
                    //shape2.image(img2,0,0)
                    shape2.pop()
                    //console.log(i)
                }
                shape2.pop()
            }

        });
        shapes.set(5.1, (n, d, tr, an, x, y) => {
            var title = 'tetrahedrom photo and lines'
            var l = min(width, height);
            let vert = getTetraVert(l * sqrt(2)) //2*sqrt(2)
            //shapes.get(0.4).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            //shapes.get(4.7).apply(null, [4, l, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            shape2 = createGraphics(l, l, WEBGL);
            //let sh=shape2.get(0,0,l,l)
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            //console.log(JSON.stringify(t))
            if (int(d) % 2 == 0) {
                vert.sort(compareZ);
            }
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            //shape2.clear()
            let coln = img[org].get(x, y)
            // shape2.specularMaterial(red(coln)*0.1);
            // shape2.pointLight(red(coln),green(coln),blue(coln), l*118, -l*122, l*118);
            //shape2.directionalLight(0,green(coln),blue(coln),0,0,-l*100)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            shape2.rotate(an)
            var wei = l * 4 / n / 6
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            for (let i = 0; i < vert.length; i++) {

                coln = imgs[i].get(colx, coly)


                shape2.push()
                //shape2.ambientMaterial(red(coln),green(coln),blue(coln));
                //shape2.emissiveMaterial(red(coln)*0.1,green(coln)*0.1,blue(coln)*0.1)
                //shape2.shininess(lightness(coln));
                shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
                shape2.texture(imgs[i])
                //shape2.rotate(blue(coln))
                shape2.ellipse(0, 0, l * 4 / n, l * 4 / n)
                //shape2.sphere(l*1/n)

                //shape2.ellipse(0,0, l,l)
                //shape2.image(img2,0,0)
                shape2.pop()
                //console.log(i)


                if (i < vert.length - 1) {
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                    shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                    shape2.endShape();

                } else {
                    //shape2.noStroke() 
                    //shape2.texture(imgs[i])
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[0].x, vert[0].y, vert[0].z);
                    shape2.vertex(vert[2].x, vert[2].y, vert[2].z);
                    shape2.endShape();
                }

                shape2.noStroke()

            }
            for (i = 0; i < vert.length; i++) {

                //coln=imgs[i].get(colx,coly)

            }
            shape2.pop()
        });

        shapes.set(5.2, (n, d, tr, an, x, y) => {
            var title = 'Box photo interior'
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            let anr=0
            var wei = l * 4 / n / 6
            let vert = getBoxVert(l*1.2-wei*0, l * 4)
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
           
            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
             var edgi=vert[0]
            cut3D(imgs[0], x, y, 1, 100, d, an, [vert[edgi.edge[1]],vert[edgi.face],vert[0],vert[edgi.edge[0]] ])
            edgi=vert[1]
            cut3D(imgs[1], x, y, 1, 100, d, an, [vert[1],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
             edgi=vert[3]
            cut3D(imgs[3], x, y, 1, 100, d, an, [vert[3],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
             edgi=vert[2]
            cut3D(imgs[2], x, y, 1, 100, d, an, [vert[2],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
            cut3D(imgs[4], x, y, 1, 100, d, an, [vert[7],vert[6],vert[4],vert[5]])
             if(floor(d)%2==0){
                var colni = imgs[0].get(colx, coly)
                for (let i = 0; i < vert.length; i++) {
                    coln = imgs[i].get(colx, coly)
                    for(var a=0;a<vert[i].edge.length;a++){
                        shape2.strokeWeight(wei)
                        shape2.stroke(colni)
                        shape2.beginShape();
                        shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                        edgi=vert[i].edge[a]
                        shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
                        //shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                        shape2.endShape();
                    }
                    shape2.noStroke()
                }
            }
            shape2.pop()
        });
        shapes.set(5.21, (n, d, tr, an, x, y) => {
            var title = 'Box photo interior floor pattern'
            var l = min(width, height);
            var suelo=[0,-0.14,3.51,4.51,-0.141]
            var soli=floor(d)%5;
            if(soli>0){
            shapes.get(suelo[soli]).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta=shape2.get(0,0,l,l) 
            }
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            let anr=0
            var wei = l * 4 / n / 6
            let vert = getBoxVert(l*1.2-wei*0, l * 4)
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
           
            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
             var edgi=vert[0]
            //cut3D(imgs[0], x, y, 1, 100, d, an, [vert[0],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
             if(soli==0){
                cut3D(imgs[0], x, y, 1, 100, d, an,[vert[edgi.edge[1]],vert[edgi.face],vert[0],vert[edgi.edge[0]] ])
            }else{
                cut3D(geta, x, y, 1, 100, d, an,[vert[edgi.edge[1]],vert[edgi.face],vert[0],vert[edgi.edge[0]] ])
            }
            edgi=vert[1]
            cut3D(imgs[1], x, y, 1, 100, d, an, [vert[1],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
             edgi=vert[3]
            cut3D(imgs[3], x, y, 1, 100, d, an, [vert[3],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
             edgi=vert[2]
            cut3D(imgs[2], x, y, 1, 100, d, an, [vert[2],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
            //if(soli<2){
                cut3D(imgs[4], x, y, 1, 100, d, an, [vert[7],vert[6],vert[4],vert[5]])
            //}else{
               //cut3D(geta, x, y, 1, 100, d, an, [vert[7],vert[6],vert[4],vert[5]]) 
            //}
             if(floor(d)%2==0){
                var colni = imgs[0].get(colx, coly)
                for (let i = 0; i < vert.length; i++) {
                    coln = imgs[i].get(colx, coly)
                    for(var a=0;a<vert[i].edge.length;a++){
                        shape2.strokeWeight(wei)
                        shape2.stroke(colni)
                        shape2.beginShape();
                        shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                        edgi=vert[i].edge[a]
                        shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
                        //shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                        shape2.endShape();
                    }
                    shape2.noStroke()
                }
            }
            shape2.pop()
        });
        shapes.set(5.22, (n, d, tr, an, x, y) => {
            var title = 'Cubeoctahedron'
            var l = min(width, height);
            //shapes.get(3.6).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            //var geta=shape2.get(0,0,l,l)
            //geta.resize(l/4,l/4)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            //let sh=shape2.get(0,0,l,l)
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            //var wei = l * 4 / n / 6
            var wei=(l/30)
            //let vert = getBoxData(l*1.2-wei*0, l * 4)
            let vert = getBoxData(l*1.2, l * 0.5)
            //for (var j = 0; j < vert.length; j++) {
            for (var j = 0; j < 4; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            let coln = img[org].get(x, y)
            shape2.push()

            shape2.translate(0, 0, -l * 1)
            if(floor(d)%2==0){
            //shape2.rotateY(an)
            }else{
                //shape2.rotateY(0)
            }
            //shape2.rotate(anr)            
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            var colni = imgs[0].get(colx, coly)
            //for (let i = 0; i < vert.length; i++) {
                //-->coln = imgs[i].get(colx, coly)
                //-->shape2.push()
                //-->shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
                //shape2.texture(imgs[i])
                //-->shape2.fill(coln)
                //-->shape2.ellipse(0, 0, wei,  wei)
                //shape2.ellipse(0, 0, wei*2,  wei*2)
                //rect(0,0,30,30)
                //shape2.image(geta,-l/4,-l*4)
                //-->shape2.pop()
                //for(var a=0;a<vert[i].edge.length;a++){
                let edga=0
                let edge=0 
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                edga=facel[0][0][0]
                edge=facel[0][0][1]
                facel[0][0][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[0][1][0]
                edge=facel[0][1][1]
                facel[0][1][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                //line31(vert,facel[0][0][2],facel[0][1][2])
                 edga=facel[0][2][0]
                edge=facel[0][2][1]
                facel[0][2][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                 edga=facel[0][3][0]
                edge=facel[0][3][1]
                facel[0][3][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)

                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                edga=facel[5][0][0]
                edge=facel[5][0][1]
                facel[5][0][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[5][1][0]
                edge=facel[5][1][1]
                facel[5][1][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[5][2][0]
                edge=facel[5][2][1]
                facel[5][2][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[5][3][0]
                edge=facel[5][3][1]
                facel[5][3][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                edga=facel[6][0][0]
                edge=facel[6][0][1]
                facel[6][0][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[6][1][0]
                edge=facel[6][1][1]
                facel[6][1][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[6][2][0]
                edge=facel[6][2][1]
                facel[6][2][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                edga=facel[6][3][0]
                edge=facel[6][3][1]
                facel[6][3][2]=mpoint2(vert,edga,edge)
                shape2.strokeWeight(wei)
                shape2.stroke(colni)
                //line3(vert,edga,edge)
                let k=5

                line31(vert,facel[k][0][2],facel[k][1][2])
                line31(vert,facel[k][1][2],facel[k][2][2])
                line31(vert,facel[k][2][2],facel[k][3][2])
                line31(vert,facel[k][3][2],facel[k][0][2]) 
                cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][0][2],facel[5][1][2],facel[6][1][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][1][2],facel[5][2][2],facel[6][2][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][2][2],facel[5][3][2],facel[6][3][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][3][2],facel[5][0][2],facel[6][0][2]])
                k=6
                line31(vert,facel[0][0][2],facel[k][0][2])
                line31(vert,facel[k][0][2],facel[5][0][2])
                line31(vert,facel[5][0][2],facel[k][1][2])
                line31(vert,facel[k][1][2],facel[0][0][2])
                j=1
                line31(vert,facel[0][j][2],facel[k][j][2])
                line31(vert,facel[k][j][2],facel[5][j][2])
                line31(vert,facel[5][j][2],facel[k][j+1][2])
                line31(vert,facel[k][j+1][2],facel[0][j][2])

                j=2
                line31(vert,facel[0][j][2],facel[k][j][2])
                line31(vert,facel[k][j][2],facel[5][j][2])
                line31(vert,facel[5][j][2],facel[k][j+1][2])
                line31(vert,facel[k][j+1][2],facel[0][j][2])

                j=3
                line31(vert,facel[0][j][2],facel[k][j][2])
                line31(vert,facel[k][j][2],facel[5][j][2])
                line31(vert,facel[5][j][2],facel[k][0][2])
                line31(vert,facel[k][0][2],facel[0][j][2])

               
               
                line32(vert,facel[0][0][0],facel[0][0][2])
                line32(vert,facel[0][0][0],facel[6][0][2])
                line32(vert,facel[0][0][0],facel[0][3][2])
               cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][0][0]],facel[6][0][2],facel[0][3][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][0][0]],facel[6][0][2],facel[0][0][2]])
                line32(vert,facel[0][1][0],facel[0][0][2])
                line32(vert,facel[0][1][0],facel[6][1][2])
                line32(vert,facel[0][1][0],facel[0][1][2])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][1][0]],facel[6][1][2],facel[0][0][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][1][0]],facel[6][1][2],facel[0][1][2]])
                line32(vert,facel[0][2][0],facel[0][1][2])
                line32(vert,facel[0][2][0],facel[6][2][2])
                line32(vert,facel[0][2][0],facel[0][2][2])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][2][0]],facel[6][2][2],facel[0][2][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][2][0]],facel[6][2][2],facel[0][1][2]])
                line32(vert,facel[0][3][0],facel[0][2][2])
                line32(vert,facel[0][3][0],facel[6][3][2])
                line32(vert,facel[0][3][0],facel[0][3][2])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][3][0]],facel[6][3][2],facel[0][2][2]])
                cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][3][0]],facel[6][3][2],facel[0][3][2]])
                // const wh = { w: img[org].width, h: img[org].height };
            //const t = rectToSquare(wh, x, y, d)
            var geti = img[org].get(t.tl.x, t.tl.y, t.w, t.w)

                k=5
                cut3D(imgs[0], x, y, 1, 100, d, an, [facel[k][0][2],facel[k][1][2],facel[k][3][2],facel[k][2][2]])
                 k=6
                cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][0][2],facel[k][1][2],facel[k][0][2],facel[0][0][2]])
                cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][1][2],facel[k][2][2],facel[k][1][2],facel[0][1][2]])
                 cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][2][2],facel[k][3][2],facel[k][2][2],facel[0][2][2]])
                  cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][3][2],facel[k][0][2],facel[k][3][2],facel[0][3][2]])
                var gete=shape2.get(0,0,l,l)
                shape2.push()
                shape2.translate(0, 0,-l)
                shape2.image(gete,0,0,l*1,l*1)


                //}
                //if(i<4) {
                    /* 
                    shape2.beginShape()
                    shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                    edgi=vert[i].face
                    shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
                    shape2.endShape();
                    shape2.fill(255)
                    shape2.noStroke()
                    shape2.push()
                    shape2.translate(vert[i].mid.x,vert[i].mid.y,vert[i].mid.z)
                    shape2.ellipse(0,0,40,40)
                    shape2.pop()
                    //if(i>3){
                       shape2.push()
                        shape2.stroke(255)
                        shape2.noFill()
                        shape2.translate(vert[i].midef.x,vert[i].midef.y,vert[i].midef.z)
                         if(i>4){

                            shape2.ellipse(0,0,40,40)
                        }
                        if(i==4|| i==6){
                            shape2.rotateX(HALF_PI)
                            shape2.ellipse(0,0,280,280)
                        }
                        if(i==5|| i==7){
                            shape2.rotateY(HALF_PI)
                            shape2.ellipse(0,0,280,280)
                        }
                       
                        
                        shape2.pop()
                        */
                    //}
                    //console.log('mid',vert[i].mid.x,vert[i].mid.y,vert[i].mid.z)
                //}
                
            //}
            shape2.pop()
        });

        shapes.set(5.3, (n, d, tr, an, x, y) => {
            var title = "Sun and floor";
            var l = min(width, height);
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            const vert = getPlaneMidSide(l, l * 10, l * 3.48)
            shape2.push()

            shape2.translate(-l * 2, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.pop()
        });

        shapes.set(5.31, (n, d, tr, an, x, y, gete = img[org]) => {
            var title = "Sun and floor";
            var l = min(width, height);
            //shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);

            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            const vert = getPlaneMidSide(l, l * 10, l * 2 * an)
            shape2.push()

            shape2.translate(-l * 2, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.pop()
        });
        shapes.set(5.4, (n, d, tr, an, x, y, gete = img[org]) => {
            var title = 'Star photo and lines'
            var l = min(width, height);
            let vert = getStarN(n, l * 0.5, -4, -4)
            shape2 = createGraphics(l, l, WEBGL);
            //let sh=shape2.get(0,0,l,l)
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            //console.log(JSON.stringify(t))
            //if(int(d)%2==0){
            //vert.sort(compareZ);
            //}
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            shape2.rotate(an)
            var wei = l * 4 / n / 6
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            for (let i = 0; i < vert.length; i++) {
                coln = imgs[i].get(colx, coly)
                shape2.push()
                shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
                shape2.texture(imgs[i])
                shape2.ellipse(0, 0, wei * 2.5, wei * 2.5)
                shape2.pop()
                if (i < vert.length - 1) {
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                    shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                    shape2.endShape();

                }
                if (i % 3 == 0 && i > 2) {}
                shape2.noStroke()
            }
            shape2.strokeWeight(wei)
            shape2.stroke(coln)
            shape2.beginShape();
            shape2.vertex(vert[vert.length - 1].x, vert[vert.length - 1].y, vert[vert.length - 1].z);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z);
            shape2.endShape();
            shape2.pop()

        });
    }


    function cutTriangle(org, x, y, n, r, d, an = 1, extra = {}) {
        if (n == 1) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 2) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0 + r * sin(HALF_PI / 3), 0, x, y + d * sin(HALF_PI / 3));
            shape2.vertex(
                0 + r * cos(HALF_PI / 3),
                0 + r * sin(HALF_PI / 3),
                0,
                x + d * cos(HALF_PI / 3),
                y + d * sin(HALF_PI / 3)
            );
            shape2.vertex(0, 0, 0, x, y);
            shape2.endShape(CLOSE);
        }

        if (n == 3) {
            //Cut arrow 1/3 from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);
            shape2.vertex(
                0 + r * cos(HALF_PI / 3),
                0 + r * sin(HALF_PI / 3),
                0,
                x + d * cos(HALF_PI / 3),
                y + d * sin(HALF_PI / 3)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }

        if (n == 4) {
            //Cut arrow aperture from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 5) {
            //Cut isosceles aperture from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, r * sin(an), 0, x, y + d * sin(an));

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 6) {
            //Cut section from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(0),
                0 + r * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 6.1) {
            const r2 = 1.42; //2root aprox
            //Cut section from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * r2 * cos(an),
                0 + r * r2 * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * r2 * cos(0),
                0 + r * r2 * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 7) {
            //Cut semi section deltoid (diamond) from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r / 2 * cos(an),
                0 + r / 2 * sin(an),
                0,
                x + d / 2 * cos(an),
                y + d / 2 * sin(an)
            );
            shape2.vertex(
                0 + r * cos(0),
                0 + r * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 8) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(r, 0, 0, x + d, y);
            shape2.endShape(CLOSE);
        }
        if (n == 9) {
            //Cut semi section quart squrae centered
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(
                -r / 2,
                r / 2,
                0,
                x - d / 2,
                y + d / 2
            );
            shape2.vertex(
                r / 2,
                r / 2,
                0,
                x + d / 2,
                y + d / 2
            );
            shape2.vertex(
                r / 2,
                -r / 2,
                0,
                x + d / 2,
                y - d / 2
            );
            shape2.endShape(CLOSE);
        }
        if (n == 10) {
            //Cut semi section deltoid from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            var r1 = r / 3
            var r2 = r / 2
            var r3 = r

            var d1 = d / 3
            var d2 = d / 2
            var d3 = d

            const p = []
            p[0] = { x: r1, y: 0 }
            p[1] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[2] = { x: r3, y: 0 }
            const s = []
            s[0] = { x: x + d1, y: y }
            s[1] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[2] = { x: x + d3, y: y }

            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.endShape(CLOSE);
        }

    }



    function getSemisides(sqr, w, h) {
        // Calcula la proporción entre el lado del cuadrado y el lado mayor del rectángulo
        const propor = sqr / Math.max(w, h);

        // Calcula las nuevas dimensiones del rectángulo
        const ww = w * propor;
        const hh = h * propor;

        // Devuelve la mitad de las nuevas dimensiones y la proporción en un array
        return [ww, hh, propor];
    }


    function calcRectSides(a, d) {
        // Calcula la longitud del lado perpendicular al apoyado
        var w = d * Math.cos(a);

        // Calcula la longitud del lado apoyado
        var h = d * Math.sin(a);

        // Devuelve los semilados del rectángulo
        return { w: w, h: h };
    }

    function cutSquare(org, x, y, n, r, d, an = 1, extra = {}) {
        if (n == 0) {
            const wh = { w: img[org].width, h: img[org].height };
            const t = rectToSquare(wh, x, y, d)
            //const t= rectToSquare(wh,0,0,wh.w)
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-r, -r, 0, t.tl.x, t.tl.y);
            shape2.vertex(-r, r, 0, t.tl.x, t.tl.y + t.w);
            shape2.vertex(r, -r, 0, t.br.x, t.br.y - t.w);
            shape2.vertex(r, r, 0, t.br.x, t.br.y);
            shape2.endShape(CLOSE);
        }
        if (n == 0.1) {
            const wh = { w: img[org].width, h: img[org].height };
            //const t = rectToSquare(wh, x, y, d)
            //const t= rectToSquare(wh,0,0,wh.w)
            //var u=getSemisides(r, wh.w, wh.h)
            ////console.log('getSemisides(',r,wh.w,wh.h,')',JSON.stringify(u))

            /*
            var w=(d);
            const r1=(r)
            var ratio=1 
            let ls=wh.w;let ss=wh.h
            if(abs(an-HALF_PI/2) > 0.0000001){
                const w=d*sin(an)
        
                 if(an>HALF_PI/2){
                    ls = d; // Longer side
                    ss = d* Math.cos(an); // Shorter side
                    ratio = ls / ss; // ratio long to short

                }else{
                    ls = d* Math.cos(an); // Longer side
                    ss = d; // 
                    ratio = ss / ls; //ratio shorth to long
                }
            
            
            //w= 2 * ls * Math.cos(an);
           }
           */

            //const t=squareToRect(wh, x, y, ls, ss)
            var sd = calcRectSides(an, d)
            const t = { tl: { x: x - sd.w, y: y - sd.h }, br: { x: x + sd.w, y: y + sd.h }, w: sd.w * 2, h: sd.h * 2 }
            var u = getSemisides(r, sd.w, sd.h)
            //console.log('w,h:', JSON.stringify(wh))
            //console.log('lados:', JSON.stringify(sd))
            //console.log('vertices:', JSON.stringify(t))
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-u[0], -u[1], 0, t.tl.x, t.tl.y);
            shape2.vertex(-u[0], u[1], 0, t.tl.x, t.tl.y + t.h);
            shape2.vertex(u[0], -u[1], 0, t.br.x, t.br.y - t.h);
            shape2.vertex(u[0], u[1], 0, t.br.x, t.br.y);
            shape2.endShape(CLOSE);
        }
        if (n == 0.4) {
            const wh = { w: img[org].width, h: img[org].height };
            const t = rectToSquare(wh, x, y, d)
            let r1 = r
            let r2 = r * 2
            let r4 = r * 4
            //const t= rectToSquare(wh,0,0,wh.w)
            let pa = createGraphics(r2, r2, WEBGL);
            //let geri=img[org].get(t.tl.x,t.tl.y,t.w,t.h)
            let geri = img[org].get(x, y, d, d)
            pa.push();
            pa.image(geri, 0, 0, r, r);
            /* pa.scale(-1, 1);
             pa.translate(-r2, 0);
             pa.image(geri, 0, 0);
             pa.scale(1, -1);
             pa.translate(0, -r2);
             pa.image(geri, 0, 0);
             pa.scale(-1, 1);
             pa.translate(-r2, 0);
             pa.image(geri, 0, 0);
             */
            pa.pop();
            shape2.image(pa, 0, 0)
            //let im4=image(pa,0,0)
            //shape2 = createGraphics(r2,r2);
            //let gera=pa.get(0,0,r2*1,r2*1)
            for (var a = 0; a < 4; a++) {
                ////shape2.image(gera,a*r,0)
            }
            //shape2.image(gera,0,0)
            // shape2.textureWrap(MIRROR);
            /*
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(gera);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-r, -r, 0, 0,  0);
            shape2.vertex(-r, r, 0, 0, r2);
            shape2.vertex(r, -r, 0, r2,  0 );
            shape2.vertex(r, r, 0, r2,  r2);
            shape2.endShape(CLOSE);
            image(shape2,0,0)
            */
        }
        if (n == 1) {
            //cut half square
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 4;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.vertex(r, -r, 0, x + d, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 2) {
            // cut half rectangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 2;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(an, r, 0, x + an, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.vertex(an, -r, 0, x + an, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 3) {
            // cut quarter rectangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 2;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, 0, 0, x, y);
            shape2.vertex(r, 0, 0, x + d, y);
            shape2.endShape(CLOSE);
        }

        if (n == 4) {
            //Cut leaf from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            //var r=200
            var r1 = r / 4
            var rr1 = r / 2.5
            var r2 = r / 2
            var rr2 = (r / 3) * 2
            var r3 = r

            var d1 = d / 4
            var dd1 = d / 2.5
            var d2 = d / 2
            var dd2 = (d * 3) * 2
            var d3 = d

            const p = []
            p[0] = { x: r1 * cos(an), y: r1 * sin(an) }
            p[1] = { x: rr1, y: 0 }
            p[2] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[3] = { x: rr2, y: 0 }
            p[4] = { x: r3 * cos(an), y: r3 * sin(an) }
            // console.log('AN:'+JSON.stringify(p))
            const s = []
            s[0] = { x: x + d1 * cos(an), y: y + d1 * sin(an) }
            s[1] = { x: x + dd2, y: y }
            s[2] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[3] = { x: x + dd2, y: y }
            s[4] = { x: x + d3 * cos(an), y: y + d3 * sin(an) }
            shape2.vertex(
                p[4].x,
                p[4].y,
                0,
                s[4].x,
                s[4].y
            );
            shape2.vertex(
                p[3].x,
                p[3].y,
                0,
                s[3].x,
                s[3].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.endShape(CLOSE);
        }
        if (n == 5) {
            //Cut leaf from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            //var r=200
            var r1 = r * 0.5
            var rr1 = r * 0.5
            var r2 = r * 0.75
            var rr2 = r
            var r3 = r

            var d1 = d * 0.5
            var dd1 = d * 0.5
            var d2 = d * 0.75
            var dd2 = d
            var d3 = d

            const p = []
            p[0] = { x: r1 * cos(an), y: r1 * sin(an) }
            p[1] = { x: rr1, y: 0 }
            p[2] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[3] = { x: rr2, y: 0 }
            p[4] = { x: r3 * cos(an), y: r3 * sin(an) }
            // console.log('AN:'+JSON.stringify(p))
            const s = []
            s[0] = { x: x + d1 * cos(an), y: y + d1 * sin(an) }
            s[1] = { x: x + dd2, y: y }
            s[2] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[3] = { x: x + dd2, y: y }
            s[4] = { x: x + d3 * cos(an), y: y + d3 * sin(an) }
            shape2.vertex(
                p[4].x,
                p[4].y,
                0,
                s[4].x,
                s[4].y
            );
            shape2.vertex(
                p[3].x,
                p[3].y,
                0,
                s[3].x,
                s[3].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.endShape(CLOSE);
        }

    }
    ///////////////////////////////////


    function compareZ(a, b) {
        return b.z - a.z;
    }

    function getTetraVert(sideLength) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [0.25, 0.25, 0.25],
            [-0.25, 0.5, 0.25],
            [0.25, -0.25, 0.25],
            [-0.25, -0.25, -0.25],
        ];
        const scalingFactor = sideLength / Math.sqrt(2);
        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {
                vert[i][j] *= scalingFactor;
            }
        }
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

    function getPlaneMidSide(sside, prof = 1, app = 0) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [-sside, 0, 0],
            [sside, 0, 0],
            [-sside, -app, -prof],
            [sside, -app, -prof],
        ];
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

 function getBoxVert(scalingFactor, prof) {
        const type = 'box_centered'
        const center = [0, 0, 0];
        const vert = [
            [-0.5, 0.5, 0.5,[1,4],5], // Vér 0
            [0.5, 0.5, 0.5,[2,5],6], // Vert 1
            [0.5, -0.5, 0.5,[3,6],7], // Vert 2
            [-0.5, -0.5, 0.5,[0,7],4], // Vert 3
            [-0.5, 0.5, -0.5,[5],1], // Vert 4
            [0.5, 0.5, -0.5,[6],2], // Vert 5
            [0.5, -0.5, -0.5,[7],3], // Vert 6
            [-0.5, -0.5, -0.5,[4],0], // Vert 7
        ];
        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {
                vert[i][j] *= scalingFactor;
                if (i > 3 && j == 2) {
                    vert[i][j] -= prof
                }

            }
        }  
         return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
                edge:p[3],
                face:p[4],
            };

        });
    } 

 function ivertex(scaling, p) {
  let v = [
    [-0.5, 0.5, 0.5], // Vértice 0
    [0.5, 0.5, 0.5], // Vértice 1
    [0.5, -0.5, 0.5], // Vértice 2
    [-0.5, -0.5, 0.5], // Vértice 3
    [-0.5, 0.5, -0.5], // Vértice 4
    [0.5, 0.5, -0.5], // Vértice 5
    [0.5, -0.5, -0.5], // Vértice 6
    [-0.5, -0.5, -0.5], // Vértice 7
  ];

  for (let i = 0; i < v.length; i++) {
    for (let j = 0; j < 3; j++) {
      v[i][j] *= scaling;

      if (i > 3 && j == 2) {
        v[i][j] -= p;
      }
    }
  }
  return v;
}

function evertex(sx, sy, sz) {
  let v = [
    [0, 0, 0], // Vértice 0
    [1, 0, 0], // Vértice 1
    [1, -1, 0], // Vértice 2
    [0, -1, 0], // Vértice 3
    [0, 0, -1], // Vértice 4
    [1, 0, -1], // Vértice 5
    [1, -1, -1], // Vértice 6
    [0, -1, -1], // Vértice 7
  ];
  for (let i = 0; i < v.length; i++) {
    v[i][0] *= sx;
    v[i][1] *= sy;
    v[i][2] *= sz;
  }
  return v;
}
const facel = [
  // Cara delantera 0
  [
    [0, 1],
    [1, 2],
    [2, 3],
    [3, 0],
  ],

  //cara lateral 1
  [
    [0, 1],
    [1, 5],
    [5, 4],
    [4, 0],
  ],
  //cara lateral 2
  [
    [1, 2],
    [2, 6],
    [6, 5],
    [5, 1],
  ],
  //cara lateral 3
  [
    [2, 3],
    [3, 7],
    [7, 6],
    [6, 2],
  ],
  //cara lateral 4
  [
    [3, 0],
    [0, 4],
    [4, 7],
    [7, 3],
  ],
  // Caras posterior 5
  [
    [4, 5],
    [5, 6],
    [6, 7],
    [7, 4],
  ],
    // aristas laterales
  [
    [0, 4],
    [1, 5],
    [2, 6],
    [3, 7],
  ],
];


function mpoint(vert,f) {

  var v1 = f[0];
  var v2 = f[1];
  var v5 = createVector(vert[v1][0], vert[v1][1], vert[v1][2]);
  var v6 = createVector(vert[v2][0], vert[v2][1], vert[v2][2]);
  return p5.Vector.lerp(v5, v6, 0.5);
  
}
function mpoint2(vert,a,e) {
  var v5 = createVector(vert[a].x, vert[a].y, vert[a].z);
  var v6 = createVector(vert[e].x, vert[e].y, vert[e].z);
  var a= p5.Vector.lerp(v5, v6, 0.5); 
  return {x:a.x, y:a.y, z:a.z}
}
function line3(vert,a,e){
    shape2.beginShape();
    shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
    shape2.vertex(vert[e].x, vert[e].y, vert[e].z);
    shape2.endShape(); 
}
function line31(vert,a,e){
    shape2.beginShape();
    shape2.vertex(a.x, a.y, a.z);
    shape2.vertex(e.x, e.y, e.z);
    shape2.endShape();
}
function line32(vert,a,e){
    shape2.beginShape();
    shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
    shape2.vertex(e.x, e.y, e.z);
    shape2.endShape();
}
 function getBoxData(scalingFactor, prof) {
    /*
          7 -------- 6
         /|         /|
        3 -------- 2 |
        | |        | |
        | |   i    | |
        | 4 -------| 5
        |/         |/
        0e ------- 1
      */
   
   let vert=ivertex(scalingFactor,prof)     
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };

        });

   }

function getHelixBoxVert(scalingFactor, prof) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [-0.5, 0.5, 0.5], // Vértice 1
            [0.5, 0.5, 0.5], // Vértice 2
            [0.5, -0.5, 0.5], // Vértice 3
            [-0.5, -0.5, 0.5], // Vértice 4
            [-0.5, 0.5, -0.5], // Vértice 5
            [0.5, 0.5, -0.5], // Vértice 6
            [0.5, -0.5, -0.5], // Vértice 7
            [-0.5, -0.5, -0.5], // Vértice 8
        ];

        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {

                vert[i][j] *= scalingFactor;
                if (i > 3 && j == 2) {
                    vert[i][j] -= prof
                }
            }
            if (i == vert.length - 1) {
                vert[i][2] -= prof
            }
        }
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

    function getStar(scale, z1) {
        const verts = [];
        let radius;
        let z = 1
        for (let i = 0; i < 10; i++) {
            //radius = i % 2 === 0 ? 1 : 0.5;
            if (i % 2 === 0) {
                radius = 1;
                z = z1
            } else {
                radius = 0.5;
                z = z1 * scale
            }
            const angle = i * Math.PI / 5;
            const x = radius * Math.cos(angle) * scale;
            const y = radius * Math.sin(angle) * scale;
            verts.push({ x, y, z });
        }
        return verts;
    }

    function getStarN(numPoints, scale, z1, z2) {
        const verts = [];
        let radius;
        let z = 1
        for (let i = 0; i < numPoints; i++) {
            if (i % 2 === 0) {
                radius = 1;
                z = z1
            } else {
                radius = 0.5;
                z = z2
            }
            //const angle = i * Math.PI / numPoints;
            const angle = (2 * Math.PI * i) / numPoints;
            const x = radius * Math.cos(angle) * scale;
            const y = radius * Math.sin(angle) * scale;
            verts.push({ x, y, z });
        }
        return verts;
    }

    /////////////////////    
    function cut3D(ime, x, y, n, r, d, an = 1, vert = []) {
        if (n == 1) {
            //plane
            var side = d
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(ime);
            var w = ime.width
            var h = ime.height
            //shape2.fill(0, 255, 0);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z, 0, 0);
            shape2.vertex(vert[1].x, vert[1].y, vert[1].z, w, 0);
            shape2.vertex(vert[2].x, vert[2].y, vert[2].z, 0, h);
            shape2.vertex(vert[3].x, vert[3].y, vert[3].z, w, h);
            shape2.endShape();
            //console.log(vert)
        }
        if (n == 2) {
            //Tetrahedrom faces
            var side = d
            //tetrahedrom
            shape2.fill(0, 255, 0);
            shape2.beginShape(TRIANGLES);
            shape2.vertex(side, side, side);
            shape2.vertex(-side, -side, side);
            shape2.vertex(side, -side, -side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(0, 0, 255);
            shape2.vertex(-side, -side, side);
            shape2.vertex(side, -side, -side);
            shape2.vertex(-side, side, -side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(255, 0, 0);
            shape2.vertex(side, side, side);
            shape2.vertex(-side, side, -side);
            shape2.vertex(-side, -side, side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(255, 255, 0);
            shape2.vertex(side, side, side);
            shape2.vertex(side, -side, -side);
            shape2.vertex(-side, side, -side);
            shape2.endShape();
        }

        if (n == 3) {
            //triangle
            var side = d
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(ime);
            var w = ime.width
            var h = ime.height
            //shape2.fill(0, 255, 0);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z, 0, 0);
            shape2.vertex(vert[1].x, vert[1].y, vert[1].z, w, h/2);
            shape2.vertex(vert[2].x, vert[2].y, vert[2].z, 0, h);
            shape2.endShape();
            //console.log(vert)
        }
    }

    function bez(t, a, b, c, d) {
        return {
            x: ((1 - t) ** 3) * a.x + 3 * (1 - t) ** 2 * t * b.x + 3 * (1 - t) * t ** 2 * c.x + t ** 3 * d.x,
            y: (1 - t) ** 3 * a.y + 3 * (1 - t) ** 2 * t * b.y + 3 * (1 - t) * t ** 2 * c.y + t ** 3 * d.y
        }
    }

    function cutShape(org, x, y, n, r, d, an = 1) {
        if (n == 1) {
            var r2 = r * 2
            var geri = img[org].get(x, y, r, r, d, d);
            var n2 = n * 2
            //var geri = a.get(x, y, n, n);
            shape2.push();
            shape2.image(geri, 0, 0);
            shape2.scale(-1, 1);
            shape2.translate(-n2, 0);
            shape2.image(geri, 0, 0);
            shape2.scale(1, -1);
            shape2.translate(0, -n2);
            shape2.image(geri, 0, 0);
            shape2.scale(-1, 1);
            shape2.translate(-n2, 0);
            shape2.image(geri, 0, 0);
            shape2.pop();
            //var ig=get(0,0,r2,r2)
            //shape2.image(ig, 0, 0);
        }
        if (n == 2) {
            // olive leaf
            //r=r*1
            //shape2.strokeWeight(12)
            //shape2.beginShape(TRIANGLE_STRIP);
            shape2.beginShape();
            //shape2.noStroke();
            //shape2.stroke(233)
            //shape2.fill(255)
            // var arry=[]
            var v = {}
            for (var a = 0; a < oliveLeaf.length; a++) {
                v = { x: x + oliveLeaf[a].x * r, y: y + oliveLeaf[a].y * r }
                //arry.push(v)
                shape2.vertex(v.x, v.y);
            }

            shape2.endShape(CLOSE);
            //console.log(JSON.stringify(arry))
        }
    }

    ///////////////
    // VERTEX SHAPES
    //////////////

    function genOlive(radio, ancho, longitud) {
        // Generar los puntos de la circunferencia.
        const puntos = [];
        for (let x = -radio; x <= radio; x++) {
            const y = Math.sqrt(radio * radio - x * x);
            puntos.push({
                x: x + ancho / 2,
                y: y * longitud / radio
            });
        }
        return puntos;
    }


    function genPoint(x, A, B, C) {
        return {
            x: x,
            y: A * Math.sin(B * x) + C
        };
    }



    function genOlive2() {
        const rect = {
            x: -1,
            y: -1,
            width: 12,
            height: 12
        };

        const puntos = [];

        // Generar el punto del ápice
        puntos.push({
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
        });
        /*
          A es la amplitud de la curva
          B es la frecuencia de la curva
          C es el desplazamiento vertical de la curva
          */
        let A = 1
        let B = 2
        let C = 6
        // Generar los puntos de la hoja
        var max = rect.x + rect.width
        var step = max / 12
        for (let x = rect.x; x <= max; x += step) {
            puntos.push(genPoint(x, A, B, C));
        }
        const json = {
            point: puntos
        };
        return json;
    }
    const oliveLeaf = genOlive(5, 5, 10);
    //console.log('OLIVE: ' + JSON.stringify(oliveLeaf));
    </script>
</body>

</html>