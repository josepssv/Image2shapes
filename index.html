<!DOCTYPE html>
<html>

<head>
    <title>Turns an image into hundreds of them. Discover the shapes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <meta charset="utf-8">
    <script>
    </script>
    <style>
        html, body {
  margin: auto,auto;
  padding: 0;
  background-color:#111;
  font-size:20px;
  text-align:center;
  color:#444;
  font-family:arial;
}
canvas {
  display: block;
}
#drop-zone {
  border: 1px solid black;
  padding: 10px;
  background-color:#111;
  color:#ddd;
  height:200px;
}
.convert {
  background-color: #0000ff;
  color: white;
  padding: 10px 20px;
  margin: 20px 0;
  border-radius: 5px;
}
.butty {
 padding: 10px 20px;
  margin: 0;
 border-radius: 5px;
 height:40px;
}

.layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.empieza {
  font-size: 30px;
  color: white;
  text-align: center;
  font-family: "Roboto", sans-serif;
  position: relative;
  text-shadow: 1px 1px 2px #000;
 
}
.otracapa {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #555;

}
.preload {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #999;
}
.capadibujo {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background-color:#000;
  background-image: repeating-linear-gradient(36deg, rgba(15,19,15, 0.25), rgba(15,19,15, 0.25) 1px, transparent 0px, transparent 2px);
    content:".";
    display:block;
    clear:both;
    padding-bottom: 100px;
}
#canvasdiv {
  display: inline-block;
  text-align:center;
  position: relative;
}

table {
    background-color:#999;
    border-collapse:separate;
    border:solid black 1px;
    border-radius:6px;
    color: #000;
    display:inline-block;
}
#allimgs{
    margin-top:40px;
}
#myShape{
    margin-top:40px;
}
   .menu-container {
            position: fixed;
            top: 40px; /* Ajusta según la altura de tu zona superior */
            left: -250px; /* Oculta el menú inicialmente */
            width: 250px;
            height: 100%;
            background-color: #777777; /* Color de fondo del menú */
            transition: left 0.3s ease; 
            z-index: 3000;
        }

        .menu-content {
            padding: 20px;
            color: #ecf0f1; /* Color del texto del menú */
        }
    .toggle-button {
            position: fixed;
            top: 10px;
            left: 10px;
            cursor: pointer;
            z-index: 3001; /* Asegura que el botón esté encima del menú */
        }


</style>
</head>

<body>
    <main>
        <div id="header" style="position: fixed; top: 0; margin-top: 0;z-index:2000; padding-top: 0; vertical-align: top; width: 100%;  height: 40px; display:none;background-color:rgba(0,0,0,1);">
            <div class="toggle-button" onclick="toggleMenu()" style="position:absolute; top:0px;left:0px;font-size:32px;color:#aaa;">☰</div>
        </div>
        <div class="menu-container" id="menu">
            <div class="menu-content" style="font-size:16px;">
                <p class="selectShapesTypes" style="text-align: right;">
                    Colors <input type="checkbox" id="s-0" value="-0" class="selectType" checked><br>
                    Clips<input type="checkbox" id="s0" value="0" class="selectType" checked><br>
                    Lines and points <input type="checkbox" id="s1" value="1" class="selectType" checked><br>
                    Mix and random <input type="checkbox" id="s2" value="2" class="selectType" checked><br>
                    Triangles and radials <input type="checkbox" id="s3" value="3" class="selectType" checked><br>
                    Squares ad rings <input type="checkbox" id="s4" value="4" class="selectType" checked><br>
                    3D<input type="checkbox" id="s5" value="5" class="selectType" checked><br>
                </p>
                <p style="text-align: right;"><button type="button" onclick="toggleMenu()" class="butty apply" style="">Apply</button></p>
                <div style="text-align: left;">
                    <p><a class="saveCode" style="">Save code</a>
                        <p class="nameapp"><i>Image2shapes 0.94</i></p>
                </div>
            </div>
        </div>
        <div class="layer">
            <div style="background-image:url(1000.png);display:inline-block;height:350px;width:680px;"></div>
            <h1 class="empieza" style="top:-300px;"><span style="font-size:20px;">Turns an image into hundreds of them </span><br>Discover the shapes<br>
                <button type="button" id="start" class="convert">Start</button>
            </h1>
        </div>
        <div class="otracapa" style="display:none;">
            <div id="drop-zone">
                <p>click to upload:</p>
                <div id="imageUpload"></div>
                <p style="display:none">Drag and drop files here to upload.</p>
            </div>
        </div>
        <div class="preload" style="display:none;"><br><span style="margin.top:100px;font-size:24px;">loading..</span></div>
        <div class="capadibujo" style="display:none;">
            <div id="bill" style="display:none;"></div>
            <div id="allimgs" style=""></div>
            <center>
            </center>
        </div>
        <div class="shape" style="z-index:3000;position:fixed;display:none;background-color:rgba(0,0,0,0.8);top:0px;left:0px;width:100%;height:100%;margin:0px;padding:0px;">
            <center>
                <div id="myShape" class="choid" style=""></div>
            </center>
        </div>
        <div id="footer" style="position: fixed; bottom: 0; margin-top: 0; padding-top: 0; vertical-align: top; width: 100%;  height: 40px; display:none;background-color:rgba(0,0,0,1);">
            <button type="button" class="butty saveImages" style="padding:3px;display:none;background-color:#444;margin-left:44px;">Save Images</button>
            <button class="butty showSelected" style="background-color:#888;margin-left:33px;">Show selected</button>
        </div>
    </main>
    <script>
    var angle;
    var angle2;
    var radius;
    var shape;
    var shape2;
    var offset = 0;
    var factor;

    var aangle1 = 0;
    var aangle2 = 0;
    var sangle = 0
    var aini1 = 0;
    var aini2 = 0;

    var centerx = 0;
    var centery = 0;
    var diagonal2 = 100;
    var W = 400;
    var H = 400;
    var contmore = 1
    var clickCount = 1;
    var contSaved = 0;
    var coord;
    var inpt;
    var contdiv;
    var showr, showl, reloadi, savef, inum;
    var contf = 1
    var paresBase = [-0.11, -0.12, -0.13, -0.14, -0.141, -0.15, -0.16, -0.17, -0.18, 0.1, 0.4, 0.41, 0.5, 0.6, 0.7, 0.8, 0.9, 0.101, 0.102, 0.103, 0.104, 0.105, 0.106, 0.107, 0.108, 0.109, 1.1, 1.1, 1.2, 1.3, 1.5, 1.6, 1.6, 1.7, 1.8, 1.9, 1.11, 1.12, 2.1, 2.2, 3.1, 3.2, 3.21, 3.22, 3.24, 3.25, 3.3, 3.4, 3.5, 3.5, 3.51, 3.51, 3.6, 3.6, 4.1, 4.2, 4.3, 4.3, 4.4, 4.4, 4.5, 4.5, 4.51, 4.51, 4.6, 4.61, 4.62, 4.7, 4.7, 5.0, 5.1, 5.2, 5.21, 5.22, 5.3, 5.31, 5.4]
    var pares = [...paresBase]
    var polis = [4, 6, 8, 10, 12, 16, 18, 20, 32, 64]
    //pares = [...new Array(10)].map(() => 5.2);
    if (window.location.hash) {
        var n = window.location.hash.substring(1, 100)
        //alert(n)
        pares = [...new Array(10)].map(() => parseFloat(n));
    } else {
        // Fragment doesn't exist
    }

    var pary = [...pares]
    var poly = [...polis]
    var cfoto = []
    var caddy = []
    var slices = 24;
    var img = [];
    var started = false
    var imgsize = { w: 10, h: 10, propor: 1, cursor: 40 }
    var dallimgs
    var codehtml = ''
    var canvasbill
    var dmy
    var nfoto = []
    var nShape = 1;
    var savedSucure;
    let org = 0
    var lastfoto = -1
    var idSession = ''
    let checkedTypes = [];
    const shapes = new Map();

    function selectShapes(checkedTypes, pares) {
        const selectedShapes = pares.filter(
            (par) => checkedTypes.some((type) => par.toString().startsWith(type))
        );
        return selectedShapes;
    }

    $(document).ready(function() {
        const buttonStart = $("#start");
        buttonStart.on("click", function() {
            $(".layer").hide();
            $(".otracapa").show();
            var inputImage = createFileInput(handleImg);
            inputImage.parent('imageUpload')
        });

        $(".shape").click(function(e) {
            if (e.target.className != ".selectef" || e.target.className != "convert addy") {
                $(".shape").hide();
                var menu = document.getElementById("menu");
                if (menu.style.left === "0") {
                    menu.style.left = "-250px";
                }
                //$(".capadibujo").show();
                //
            }
        });




        $(".selectType").on('change', function(e) {
            const selectTypes = $('.selectType');
            checkedBoxes = selectTypes.filter(':checked');
            checkedTypes = [];
            checkedBoxes.each(function() {
                checkedTypes.push($(this).val());
            });
            pares = []
            pares = selectShapes(checkedTypes, paresBase)
            pary = [...pares]
        });

        toggleMenu()
        $(".saveImages").on("click", function() {
            saveAllImages()
        });
        $(".saveCode").on("click", function() {
            saveCode()
        });

        $(".showSelected").click(function(e) {
            savedSecure = [...cfoto]
            caddy = []
            /*cfoto.forEach(array => {
              if (Array.isArray(array)) {
                const objeto = { ...array[0] }; // Copiamos el elemento 0 de cada subarray
                caddy.push(objeto); // Agregamos el objeto copiado a objetosSeleccionados
                array.forEach(subobjeto => {
                  if (subobjeto.select === true) {
                    caddy.push(subobjeto);
                  }
                });
              }
            });
            */


            //caddy = []
            caddy.push({ ...cfoto[lastfoto][0] });

            cfoto.forEach(array => {
                if (Array.isArray(array)) {
                    array.forEach(objeto => {
                        if (objeto.select === true) {
                            const duplicado = caddy.some(obj => JSON.stringify(obj) === JSON.stringify(objeto));
                            if (duplicado) {
                                duplicado.select = false;
                            } else {
                                caddy.push(objeto);
                            }
                            //caddy.push(objeto);
                            //-->objeto.select=false
                        }
                    });
                }
            });
            cfoto.push(caddy)
            lastfoto = cfoto.length - 1
            contf = 1
            codehtml = ''
            dallimgs.html('')
            //img.push(cfoto[lastfoto][0].img)
            img[img.length] = loadImage(
                cfoto[lastfoto][0].img,
                () => {
                    slices = cfoto[lastfoto][0].n
                    loop()
                },
                () => print('Image Failed to Load.'),
            );

        });
    });

    function toggleMenu() {
        var menu = document.getElementById("menu");
        if (menu.style.left === "-250px") {
            menu.style.left = "0";
        } else {
            menu.style.left = "-250px";
        }
    }

    function handleImg(file) {
        if (file.type === "image") {
            $(".otracapa").hide();
            $(".preload").show();
            $(".capadibujo").show();
            //img2 = loadImage(file.data)

            img[0] = loadImage(
                file.data,
                () => {
                    //alert('Selected file: ' + file.value);
                    //$(".preload").show();
                    idSession = makeid(50)
                    canvasbill = createCanvas(W, H);
                    iniShapes()
                    canvasbill.parent('#bill')
                    dallimgs = select('#allimgs')

                    $(".preload").hide();
                    textSize(50);
                    frameRate(12)
                    imageMode(CENTER);
                    dmy = select('#myShape')
                    $('.shape').show()
                    reini(file.data, img[0].width, img[0].height)
                },
                () => print('Image Failed to Load.'),
            );

        };
    }

    function setup() {
        createMetaTag()
        noLoop()
    }

    function draw() {
        if (lastfoto >= 0) {
            var tt = '<div style="color:#888;margin-top:100px;font-size:33px;">' + (contf) + ' ' + (cfoto[lastfoto].length - 1) + ' shapes</div>'
            $('#myShape').html(tt)
        }
        if (started) {
            if (contmore == 1) {
                select('#header').show();
                select('#footer').show();
            }
            slices = cfoto[lastfoto][contf].n
            var d = cfoto[lastfoto][contf].d
            $('.shape').show()
            drawbill(contf, W, H, slices, d)
            contf++
            if (contf >= cfoto[lastfoto].length) {
                noLoop()
                contf = cfoto[lastfoto].length
                poly = [...polis]
                pary = [...pares]
                codehtml += '<center><button type="button" class="convert more" id="m' + contmore + '" style="display:block;">More</button></center>'
                //codehtml+='<br><button class="convert showSelected" style="background-color:#888;margin-left:33px;">Show selected</button>'
                //codehtml +='<button type="button" class="convert saveImages" style="background-color:#444;margin-left:44px;">Save Images</button>'
                //codehtml +='<button type="button" class="convert saveCode" style="background-color:#444;margin-left:44px;">Save code</button></center>'
                //$("button").remove(".more");
                dallimgs.html(codehtml, true)
                $('#allimgs').scrollTop($('#allimgs').scrollHeight);
                $('.shape').fadeOut(1000)
                codehtml = ''
                $(".forma").on("click", function() {
                    var n = this.children[0].id
                    enhance(n)
                });
                $(".more").on("click", function() {
                    $('.shape').show()
                    contmore++
                    newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
                    $("button").remove(".more");
                    $("#menu").css('left', '-250px')
                    loop()
                });

            }
        }
    }

    function drawbill(conti, w, h, slices, diagonal) {
        background(0, 0)
        clear()
        factor = 0.5
        var x = cfoto[lastfoto][conti].x;
        var y = cfoto[lastfoto][conti].y;
        var p = cfoto[lastfoto][conti].p;
        var ang = cfoto[lastfoto][conti].a;
        org = cfoto[lastfoto][conti].org;

        //var ang = 1 * random(1)
        var ns = nsides = polis[p]
        //var ns = floor(random(0, polis.length))
        //var nsides = polis[ns]
        //var nsides = polis[p]

        var rotation = 0
        //////////////////////////////////
        //var rns=floor(random(0,pares.length))
        //shapes.get(pares[rns]).apply(null,[slices,diagonal,{scl:factor,rtt:0,trx:0,try:0},ang*random(1),x,y]);
        shapes.get(slices).apply(null, [p, diagonal, { scl: factor, rtt: rotation, trx: 0, try: 0 }, ang, x, y]);

        /////////////////////////////////////
        codehtml += '<div class="forma" style="vertical-align: top;margin:0px;padding:0px;display:inline-block;width:200px;height:200px;font-size:220px;background-color:transparent;"><img id="i' + contf + '" width="200px" height="200px" src="' + shape2.canvas.toDataURL() + '"></div>'

        //nfoto[contf]=shape2.canvas.toDataURL()
        if (conti % 4 == 0) { codehtml += '<br style="height: 0;">' }

    }

    function getImageData(w, h) {
        const imgn = {
            w: w,
            h: h,
        };
        if (w >= h) {
            imgn.maxDim = w;
            imgn.minDim = h;
        } else {
            imgn.maxDim = h;
            imgn.minDim = w;
        }
        const cx = w / 2;
        const cy = h / 2;
        imgn.angle = Math.atan2(cy, cx); // Angle in radians
        imgn.semidiagonal = Math.sqrt(Math.pow(cx, 2) + Math.pow(cy, 2)); // Length from the center to the bottom right corner
        const sideLength = imgn.maxDim;
        const tlx = cx - sideLength / 2;
        const tly = cy - imgn.minDim / 2;
        const brx = cx + sideLength / 2;
        const bry = cy + imgn.minDim / 2;
        imgn.tl = {
            x: tlx,
            y: tly
        };
        imgn.br = {
            x: brx,
            y: bry
        };
        return imgn;
    }

    function reini(iimg, w, h) {
        //img=loadImage(iimg) 

        cfoto.push([{ "w": 640, "h": 963, "n": 8, "W": 300, "o": 0, "d": 640, "id": "p0a2OHWO1TXUnHfq4zQVDG5lPa1AReHkVwjj39yKGlQ7Ot6QO1", "img": "" }])

        lastfoto = cfoto.length - 1
        slices = cfoto[lastfoto][0].n
        cfoto[lastfoto][0].img = iimg
        started = true
        codehtml = ''
        nfoto = []
        cfoto[lastfoto][0].W = W
        cfoto[lastfoto][0].w = w
        cfoto[lastfoto][0].h = h

        cfoto[lastfoto][0].id = idSession

        caddy = [...cfoto[lastfoto]]

        var imgn = getImageData(w, h)
        cfoto[0].push({ "org": 0, "x": (w / 2), "y": (h / 2), "n": 0.41, "d": imgn.semidiagonal, "p": 64, "a": imgn.angle, "select": true })
        nfoto = []
        contf = 1
        nShape = 1;
        dallimgs.html(codehtml)
        $('.shape').show()
        newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
        loop();
    }


    function info(d) {

    }

    function fillRandom(values, n) {
        const result = [];
        for (let i = 0; i < n; i++) {
            const randomIndex = Math.floor(Math.random() * values.length);
            result.push(values[randomIndex]);
        }
        return result;
    }
    //var actualn=0
    var imgN

    function enhance(n) {
        //$('.capadibujo').hide()
        var dla = select('.shape')
        nShape = n.replace(/^\D+/g, '');
        //alert(nn)
        //n=2
        //actualn=n
        dla.show()
        var dmy = select('#myShape')
        imgN = select('#' + n + '').attribute('src');
        var code = '<img class=".selectef" src="' + imgN + '" width="' + 400 + 'px">';
        code += '<br><span style="color:#ddd;font-size:12px;">' + JSON.stringify(cfoto[lastfoto][nShape]) + '</span>';
        code += '<br><button class="convert downy" style="background-color:#666;">Download</button>'
        code += '<button class="convert usy" style="background-color:#a6a;">Use</button>'
        code += '<button class="convert simy" style="background-color:#a66;">Similar</button>'
        code += '<button class="convert addy" style="background-color:#aaa;">Add</button>'
        dmy.html(code)
        $(".downy").click(function(e) {
            saveImage()
        });
        $(".addy").click(function(e) {
            cfoto[lastfoto][nShape].select = true
            caddy.push(cfoto[lastfoto][nShape])


        });
        $(".usy").click(function(e) {
            caddy.push(cfoto[lastfoto][nShape])
            img[img.length] = loadImage(imgN, () => {
                var rry = [cfoto[lastfoto][nShape].n, cfoto[lastfoto][nShape].n]
                var lly = [cfoto[lastfoto][nShape].p, cfoto[lastfoto][nShape].p]
                cfoto[lastfoto][nShape].select = true
                cfoto.push([...cfoto[lastfoto]])
                lastfoto = cfoto.length - 1
                cfoto[lastfoto][0].img = imgN
                cfoto[lastfoto][0].w = img[lastfoto].width
                cfoto[lastfoto][0].h = img[lastfoto].height
                pary = fillRandom(rry, 10)
                poly = fillRandom(lly, 10)
                contmore++
                newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
                $("button").remove(".more");
                //$('.shape').show()
                loop()
            });

        });
        $(".simy").click(function(e) {
            var rry = [cfoto[lastfoto][nShape].n, cfoto[lastfoto][nShape].n]
            var lly = [cfoto[lastfoto][nShape].p, cfoto[lastfoto][nShape].p]
            pary = fillRandom(rry, 10)
            poly = fillRandom(lly, 10)
            cfoto[lastfoto][nShape].select = true
            //lastfoto=cfoto.length-1
            //$('.shape').show()
            contmore++
            newRandco(cfoto[lastfoto][0].w, cfoto[lastfoto][0].h, 4, 4, 0)
            $("button").remove(".more");
            loop()
        });
    }

    function saveImage() {

        var link = document.createElement("a");
        link.id = 'thisi';
        link.download = makeid(8) + '.png'
        link.href = imgN;
        link.click();
    }

    var savi = null

    function saveAllImages() {
        var images = document.getElementsByTagName('img');
        var srcList = [];
        var i = 0;
        var nimages = images.length
        if (nimages < 7) {
            var savi = setInterval(function() {
                if (i < nimages) {
                    srcList.push(images[i].src);
                    var link = document.createElement("a");
                    link.id = i;
                    link.download = makeid(8) + '.png'
                    link.href = images[i].src;
                    link.click();
                    i++;
                } else {
                    clearInterval(savi)
                    savi = null
                }
            }, 1500);
        }
    }

    function saveCode() {
        var nww = window.open('', 'newh')
        nww.document.write(JSON.stringify(cfoto))
    }

    function makeid(length) {
        var result = '';
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return result;
    }



    function newRandco(w, h, rows, columns, npair) {
        var pm = min(w, h)
        var margin = random(10, 50)
        var cont = 1
        //cfoto.splice(1, cfoto.length);
        let pr
        let dr
        let x, y, pxy, ang
        //var npair=0
        //var imglf=img[lastfoto]
        for (let row = 0; row < rows; row++) {
            for (let column = 0; column < columns; column++) {
                //let x = column * width / columns - margin;
                //let y = row * height / rows - margin;
                //if (x <= 0) {
                x = parseInt(Math.random() * (cfoto[lastfoto][0].w - margin))
                //}
                //if (y <= 0) {
                y = parseInt(Math.random() * (cfoto[lastfoto][0].h - margin))
                //}
                pxy = min(w - x, h - y)
                dr = random(margin, w - pxy)
                let fxy = rectToSquare({ w: w, h: h }, x, y, dr)

                pr = pary[floor(random(0, pary.length))]
                pl = poly[floor(random(0, poly.length))]
                ang = random(0.00001, 1)
                cfoto[lastfoto].push({
                    org: lastfoto,
                    x: fxy.x,
                    y: fxy.y,
                    n: pr,
                    d: fxy.w,
                    p: pl,
                    a: ang,
                    select: false
                });
                cont++
                //if(cont===floor(rows*columns/2)){npair++}
            }
        }
    }

    function rectToSquare(wh, x, y, d) {
        const s = {};
        // Adjust coordinates if they exceed the rectangle boundaries
        if (x < d / 2) {
            x = d / 2;
        } else if (x > wh.w - d / 2) {
            x = wh.w - d / 2;
        }
        if (y < d / 2) {
            y = d / 2;
        } else if (y > wh.h - d / 2) {
            y = wh.h - d / 2;
        }
        // Calculate the two points of the square
        s[0] = { x: x - d / 2, y: y - d / 2 };
        s[1] = { x: x + d / 2, y: y + d / 2 };
        return {
            tl: s[0],
            br: s[1],
            w: d,
            x: x,
            y: y,
        };
    }

    function squareToRect(wh, x, y, l, w) {
        const s = {};
        // Verificar si el ancho es mayor que la altura
        if (wh.w > wh.h) {
            if (l > wh.h) {
                l = wh.h; // Ajustar la longitud a la altura máxima
            }
            if (w > wh.h) {
                w = wh.h; // Ajustar el ancho a la altura máxima
            }
        } else {
            if (l > wh.w) {
                l = wh.w; // Ajustar la longitud al ancho máximo
            }
            if (w > wh.w) {
                w = wh.w; // Ajustar el ancho al ancho máximo
            }
        }
        // Ajustar las coordenadas si exceden los límites del rectángulo
        if (x < l / 2) {
            x = l / 2;
        } else if (x > wh.w - l / 2) {
            x = wh.w - l / 2;
        }
        if (y < w / 2) {
            y = w / 2;
        } else if (y > wh.h - w / 2) {
            y = wh.h - w / 2;
        }
        // Calcular los dos puntos del rectángulo
        s[0] = { x: x - l / 2, y: y - w / 2 };
        s[1] = { x: x + l / 2, y: y + w / 2 };
        return {
            tl: s[0],
            br: s[1],
            l: l,
            w: w,
            x: x,
            y: y,
        };
    }

    function createMetaTag() {
        //https://openprocess4.org/sketch/790331

        //Mobile Devices by Oren Shoham

        let meta = createElement("meta");

        meta.attribute("name", "viewport");

        meta.attribute(
            "content",

            "user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width,height=device-height"
        );

        let head = select("head");

        meta.parent(head);
    }


    /////////////////////////
    // shapes.js
    ////////////////////////
    //const shapes = new Map();
    //iniShapes()

    function iniShapes() {
        shapes.set(-0.11, (n, d, tr, an, x, y) => {
            var title = "simply gradient V rect to down black";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt = img[org].get(x, y)
            var geto = color(red(gt), green(gt), blue(gt))
            var geta = color(0, 0, 0)
            var geti;
            cmod = 0
            var mod = 1 / n

            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * modi, l, modi)
                cmod += mod

            }
        });
        shapes.set(-0.12, (n, d, tr, an, x, y) => {
            var title = "simply gradient V rect to colorA to colorB";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var gt2 = img[org].get(x + d, y + d)
            var geto = color(red(gt1), green(gt1), blue(gt1))
            var geta = color(red(gt2), green(gt2), blue(gt2))
            var geti;

            cmod = 0
            var mod = 1 / n

            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * modi, l, modi)
                cmod += mod

            }
        });
        shapes.set(-0.13, (n, d, tr, an, x, y) => {
            var title = "simply V color list";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var mod = l / n
            var geti
            for (let a = 0; a < n; a++) {
                geti = img[org].get(x, y + 1 * a)
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(0, a * mod, l, mod)
            }
        });
        shapes.set(-0.14, (n, d, tr, an, x, y) => {
            var title = "palette random color table in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geti
            shape2.strokeWeight(4)
            var mod = l / n
            for (let b = 0; b < n; b++) {
                for (let a = 0; a < n; a++) {
                    geti = img[org].get(x + 4 * a, y + 4 * b)
                    if (floor(d) % 2 == 0) {
                        shape2.stroke(0)
                    } else {
                        shape2.stroke(geti)
                    }
                    shape2.fill(geti)
                    shape2.rect(a * mod, b * mod, mod, mod)
                }
            }

        });
        shapes.set(-0.141, (n, d, tr, an, x, y) => {
            var title = "palette random color table in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geta = img[org].get(x, y)
            var gete = img[org].get(x + 12, y + 12)
            shape2.strokeWeight(4)
            var mod = l / n
            var npar = 0
            for (let b = 0; b < n; b++) {
                if (b % 2 == 0) { npar = 0 } else { npar = 1 }
                for (let a = 0; a < n; a++) {


                    if (a % 2 == npar) {
                        shape2.fill(geta)
                        shape2.stroke(geta)
                    } else {
                        shape2.stroke(gete)
                        shape2.fill(gete)
                    }

                    shape2.rect(a * mod, b * mod, mod, mod)
                }
            }

        });
        shapes.set(-0.15, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect to colorA to colorB";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var gt2 = img[org].get(x + d, y + d)
            var geto = color(red(gt1), green(gt1), blue(gt1))
            var geta = color(red(gt2), green(gt2), blue(gt2))
            var geti;
            cmod = 0
            var mod = 1 / n
            for (let a = 0; a < n; a++) {
                geti = lerpColor(geto, geta, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(geti)
                }
                shape2.fill(geti)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
            }
        });
        shapes.set(-0.16, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect to colorA to black";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var modi = l / n
            var gt1 = img[org].get(x, y)
            var geta = color(red(gt1), green(gt1), blue(gt1))
            var gete = color(0, 0, 0)
            var getu;
            cmod = 0
            var mod = 1 / n
            for (let a = 0; a < n; a++) {
                getu = lerpColor(geta, gete, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
            }
        });
        shapes.set(-0.17, (n, d, tr, an, x, y) => {
            var title = "simply gradient H rect black to colorA to white";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var gt1 = img[org].get(x, y)
            var cmod = 0
            var geta = color(0, 0, 0)
            var gete = color(red(gt1), green(gt1), blue(gt1))
            var geti = color(255, 255, 255)
            var getu = lerpColor(geta, gete, cmod);
            var modi = l / (n * 2 + 1)
            var mod = 1 / n
            for (let a = 0; a < n; a++) {

                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(a * modi, 0, modi, l)
                cmod += mod
                getu = lerpColor(geta, gete, cmod);
            }
            a = n
            if (floor(d) % 2 == 0) {
                shape2.stroke(0)
            } else {
                shape2.stroke(getu)
            }
            shape2.fill(gete)
            shape2.rect(a * modi, 0, modi, l)
            cmod = mod
            a += 1
            for (let b = a; b < (n * 2 + 1); b++) {
                getu = lerpColor(gete, geti, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.rect(b * modi, 0, modi, l)
                cmod += mod
            }

        });


        shapes.set(-0.18, (n, d, tr, an, x, y) => {
            var title = "Cone gradient";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
            } else {
                shape2.strokeWeight(1)
            }
            var gt1 = img[org].get(x, y)
            var cmod = 0
            var geta = color(0, 0, 0)
            var gete = color(red(gt1), green(gt1), blue(gt1))
            var geti = color(255, 255, 255)
            var getu = lerpColor(geta, gete, cmod);
            var vx1=(l/2)+l*2*cos(PI/2+(an))
            var vy1=(0)+l*2*sin(PI/2+(an))
            var vx2=(l/2)+l*2*cos(PI/2-(an))
            var vy2=(0)+l*2*sin(PI/2-(an))
            var d2=dist(vx1,vy1,vx2,vy2)
            var inip=l/2-d2/2
            var modi = d2 / (n * 2 + 1)
            var mod = 1 / n
            for (let a = 0; a < n; a++) {

                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.beginShape()
                shape2.vertex(l/2,0)
                shape2.vertex(inip+a * modi,vy1)
                shape2.vertex(inip+a * modi+modi,vy1)
                shape2.endShape(CLOSE)
                cmod += mod
                getu = lerpColor(geta, gete, cmod);
            }
            a = n
            if (floor(d) % 2 == 0) {
                shape2.stroke(0)
            } else {
                shape2.stroke(getu)
            }
            shape2.fill(gete)
            shape2.beginShape()
                shape2.vertex(l/2,0)
                shape2.vertex(inip+a * modi,vy1)
                shape2.vertex(inip+a * modi+modi,vy1)
                shape2.endShape(CLOSE)
            cmod = mod
            a += 1
            for (let b = a; b < (n * 2 + 1); b++) {
                getu = lerpColor(gete, geti, cmod);
                if (floor(d) % 2 == 0) {
                    shape2.stroke(0)
                } else {
                    shape2.stroke(getu)
                }
                shape2.fill(getu)
                shape2.beginShape()
                shape2.vertex(l/2,0)
                shape2.vertex(inip+b * modi,vy1)
                shape2.vertex(inip+b * modi+modi,vy1)
                shape2.endShape(CLOSE)
                cmod += mod
            }

        });
        shapes.set(0.1, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a square";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            var geti = img[org].get(x, y)
            shape2.noStroke()
            shape2.fill(geti)
            shape2.rect(0, 0, l, l)

        });
        shapes.set(0.4, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var cutname = 0;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            cutSquare(org, x, y, cutname, l, d);
            image(shape2, 0, 0);
            pop();
        });
        shapes.set(0.41, (n, d, tr, an, x, y) => {
            var title = "simply random cut image in a rectangle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var cutname = 0.1;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, cutname, l, d, an);
            image(shape2, 0, 0);
            pop();
        });
        shapes.set(0.5, (n, d, tr, an, x, y) => {
            var title = "rect pattern from cutted image";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var limit = (n * 1) + 1;
            var rade = l / n;
            var dx = 0;
            var dy = 0;
            let img2 = img[org].get(x, y, rade, rade);
            for (var a = 0; a < limit; a++) {
                for (var b = 0; b < limit; b++) {
                    dx = rade * a
                    dy = rade * b
                    shape2.image(img2, dx, dy);
                }
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(0.6, (n, d, tr, an, x, y) => {
            var title = "mask image with circle";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(0.61, (n, d, tr, an, x, y) => {
            var title = "mask image with circle radius";
            var l = min(width, height);
            //shape2.background(200, 50, 100);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.smooth();
            var dx = l * 2 / n
            var cx = map(x, 0, img[0].width, 0, l - dx)
            var cy = map(y, 0, img[0].height, 0, l - dx)
            shape2.push()
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(-l / 2 + dx / 2, -l / 2 + dx / 2, dx, dx)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop()
            //shape2
        });
        shapes.set(0.7, (n, d, tr, an, x, y) => {
            var title = "Vgradient 2 random colors from image";
            var c1 = img[org].get(x, y)
            var c2 = img[org].get(x + d, y + d)
            shape2 = createGraphics(width, height, WEBGL);
            shape2.beginShape(QUAD_STRIP);
            shape2.fill(c1);
            shape2.vertex(-width / 2, -height / 2);
            shape2.vertex(width / 2, -height / 2);
            shape2.fill(c2);
            shape2.vertex(-width / 2, height / 2);
            shape2.vertex(width / 2, height / 2);
            shape2.endShape();
        });
        shapes.set(0.71, (n, d, tr, an, x, y) => {
            var title = "Vgradient 2 random colors from image in circle";
            var l = min(width, height);
            var c1 = img[org].get(x, y)
            var c2 = img[org].get(x + d, y + d)
            shape2 = createGraphics(width, height, WEBGL);
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
            shape2.beginShape(QUAD_STRIP);
            shape2.fill(c1);
            shape2.vertex(-width / 2, -height / 2);
            shape2.vertex(width / 2, -height / 2);
            shape2.fill(c2);
            shape2.vertex(-width / 2, height / 2);
            shape2.vertex(width / 2, height / 2);
            shape2.endShape();
        });
        shapes.set(0.8, (n, d, tr, an, x, y) => {
            var title = "mask image with disk";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.noFill()
                shape2.strokeWeight(l / 4)
                shape2.stroke(0)
                shape2.ellipse(0, 0, l - l / 4, l - l / 4)
                shape2.pop();
            });
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(0.9, (n, d, tr, an, x, y) => {
            var title = "mask image with star";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);
            let vert = getStarN(n, l * 0.5, -4, -30)

            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.beginShape();
                shape2.fill(255);
                for (let a = 0; a < vert.length; a++) {
                    shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
                }
                shape2.endShape();
            });

            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });

        shapes.set(0.101, (n, d, tr, an, x, y) => {
            var title = "mask circle image life flower";
            var l = min(width, height);
            //shape2.background(200, 50, 100);
            shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2 = createGraphics(width, height, WEBGL);
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.push();
                shape2.ellipse(0, 0, l, l)
                shape2.pop();
            });
            shape2.image(geta, -l / 2, -l / 2)
            shape2.pop()
            //shape2
        });
        shapes.set(0.102, (n, d, tr, an, x, y) => {
            var title = "Isometric box";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.noStroke()
            if (n > 22) { n = 2 }
            var r = l / 2;
            var r3 = r * 3;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var coa = [...flower.aco[1]]
            var inp = { x: 0, y: 0 }
            if (petal) {
                flower.flowbox(1, inp, 0, r, coa);
                flower.flowbox(2, inp, 0, r, coa);
                flower.flowbox(3, inp, 0, r, coa);
            } else {
                flower.flowbox(4, inp, 0, r, coa);
                flower.flowbox(5, inp, 0, r, coa);
                flower.flowbox(6, inp, 0, r, coa);
            }
        });
        shapes.set(0.103, (n, d, tr, an, x, y) => {
            var title = "Isometric vertex";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l / 4;
            var r3 = r * 3;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var coa = [...flower.aco[1]]
            var inp = { x: 0, y: 0 }
            flower.flowbox(7, inp, 0, r, coa);
            flower.flowbox(8, inp, 0, r, coa);
            flower.flowbox(9, inp, 0, r, coa);
            flower.flowbox(10, inp, 0, r, coa);
            flower.flowbox(11, inp, 0, r, coa);
            flower.flowbox(12, inp, 0, r, coa);
        });
        shapes.set(0.104, (n, d, tr, an, x, y) => {
            var title = "3 Isometric box";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l / 4;
            var r3 = r * 3;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var coa = [...flower.aco[1]]
            var inp = { x: 0, y: 0 }
            shape2.push();
            shape2.scale(tr.scl * 2, tr.scl * 2);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            flower.flowbox(4, inp, 2, r, coa);
            flower.flowbox(5, inp, 4, r, coa);
            flower.flowbox(6, inp, 6, r, coa);
            flower.flowbox(7, inp, 0, r, coa);
            flower.flowbox(8, inp, 0, r, coa);
            flower.flowbox(9, inp, 0, r, coa);
            flower.flowbox(10, inp, 0, r, coa);
            flower.flowbox(11, inp, 0, r, coa);
            flower.flowbox(12, inp, 0, r, coa);
            shape2.pop()
        });
        shapes.set(0.105, (n, d, tr, an, x, y) => {
            var title = "3 Isometric box grid";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.noStroke()
            if (n > 22) { n = 2 }
            var r = l / 10;
            var r3 = r * 3;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var coa = [...flower.aco[1]]
            var sia = [PI / 2, PI - PI / 6, PI + PI / 6, -PI / 2, -PI / 6, PI / 6]
            var sir = [r3, r3, r3, r3, r3, r3]
            var inp = { x: 0, y: 0 }
            // flower.init()
            shape2.push();
            shape2.scale(tr.scl * 2, tr.scl * 2);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);

            flower.flowbox(4, inp, 2, r, coa);
            flower.flowbox(5, inp, 4, r, coa);
            flower.flowbox(6, inp, 6, r, coa);
            flower.flowbox(7, inp, 0, r, coa);
            flower.flowbox(8, inp, 0, r, coa);
            flower.flowbox(9, inp, 0, r, coa);
            flower.flowbox(10, inp, 0, r, coa);
            flower.flowbox(11, inp, 0, r, coa);
            flower.flowbox(12, inp, 0, r, coa);
            for (var a = 0; a < 6; a++) {
                inp = { x: sir[a] * cos(sia[a]), y: sir[a] * sin(sia[a]) }
                // console.log('rad: ',inp) 
                flower.flowbox(4, inp, 2, r, coa);
                flower.flowbox(5, inp, 4, r, coa);
                flower.flowbox(6, inp, 6, r, coa);
                flower.flowbox(7, inp, 0, r, coa);
                flower.flowbox(8, inp, 0, r, coa);
                flower.flowbox(9, inp, 0, r, coa);
                flower.flowbox(10, inp, 0, r, coa);
                flower.flowbox(11, inp, 0, r, coa);
                flower.flowbox(12, inp, 0, r, coa);
            }
            shape2.pop()
        });
        shapes.set(0.106, (n, d, tr, an, x, y) => {
            var title = "Isometric elipse";
            var l = min(width, height);
            shapes.get(0.102).apply(null, [n, d, { scl: 1, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var r = (l/2);
            var r3 = r * 3;
            //var r32 = 282.84;//sqrt(r*r + r*r);
            var  r32 = sqrt(r*r + r*r)-r/10;
            var r322= r32/2
            /*shape2.scale(tr.scl , tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            */
            shape2.push();
            var nd=64
            var co
            if(petal){
                //polis[4, 6, 8, 10, 12, 16, 18, 20, 32, 64]
                if(n==4 || n==6 || n==8 || n==64){
                co=img[org].get(x,y)
                shape2.fill(co)
                shape2.ellipse(0,-l/4,r32,r322,nd)
                }
                if(n==10 || n==12 || n==16 || n==64){
                shape2.push()
                    co=img[org].get(x+d/2,y)
                    shape2.fill(co)
                    shape2.translate(r*0.5*cos(PI/6),r*0.5*sin(PI/6))
                    shape2.rotate(PI-PI/3)
                    shape2.ellipse(0,0,r32,r322,nd)
                shape2.pop()
                 }
                 if(n==18 || n==20 || n==32 || n==64){
                shape2.push()
                    co=img[org].get(x+d/2,d/2)
                    shape2.fill(co)
                    shape2.translate(r*0.5*cos(PI-PI/6),r*0.5*sin(PI-PI/6))
                    shape2.rotate(PI+PI/3)
                    shape2.ellipse(0,0,r32,r322,nd)
                shape2.pop()
                }
            }else{
                if(n==4 || n==6 || n==8 || n==64){
                    co=img[org].get(x,y)
                    shape2.fill(co)
                    shape2.ellipse(0,l/4,r32,r322,nd)
                }
                if(n==10 || n==12 || n==16 || n==64){
                shape2.push()
                    co=img[org].get(x+d/2,y)
                    shape2.fill(co)
                    shape2.translate(r*0.5*cos(-PI/6),r*0.5*sin(-PI/6))
                    shape2.rotate(PI+PI/3)
                    shape2.ellipse(0,0,r32,r322,nd)
                shape2.pop()
                }
                if(n==18 || n==20 || n==32 || n==64){                
                shape2.push()
                    co=img[org].get(x+d/2,d/2)
                    shape2.fill(co)
                    shape2.translate(r*0.5*cos(PI+PI/6),r*0.5*sin(PI+PI/6))
                    shape2.rotate(PI-PI/3)
                    shape2.ellipse(0,0,r32,r322,nd)
                shape2.pop()
                }
            }


                            /*shape2.stroke(1   88)
            shape2.beginSha pe()
                shape2.v    ertex(0,0)
                shape2.vertex(200*cos(PI/6),200*sin(PI/6))
            shape2.endShape()*/
            shape2.pop()
        });
        shapes.set(0.107, (n, d, tr, an, x, y) => {
            var title = "Isometric cylinder";
            var l = min(width, height);
            //shapes.get(0.102).apply(null, [n, d, { scl: 1, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            shapes.get(-0.17).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var sh1=shape2.get(0,0,l,l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var r = (l/2);
            var r3 = r * 3;
            //var r32 = 282.84;//sqrt(r*r + r*r);
            //var  r32 = sqrt(r*r + r*r)-r/10;

            var r32=l
            var r322= r32/2
            /*shape2.scale(tr.scl , tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            */
            shape2.push();
            var co
            shape2.beginClip()
                //co=img[org].get(x,y)
                //shape2.fill(co)
                shape2.rect(-l/2,-l/4,l,l-l/2)
                shape2.ellipse(0,l/4,r32,r322,64)
            shape2.endClip()
           shape2.image(sh1,-l/2,-l/4) 
           shape2.pop()
           co=img[org].get(x,y)
            if (floor(d) % 2 == 0) {
                shape2.strokeWeight(4)
                shape2.stroke(0)
            } else {
                shape2.strokeWeight(4)
                shape2.stroke(co)
            }
             shape2.fill(co)
             shape2.ellipse(0,-l/4,r32,r322,n*4)
           
        });
////
 shapes.set(0.108, (n, d, tr, an, x, y) => {
     var title = "ortogonal cone";
     var l = min(width, height);
     shape2 = createGraphics(l, l, WEBGL);
    shapes.get(-0.18).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var sh1=shape2.get(0,0,l,l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            shape2.push();
            var circone= new Circone(0,-l/2,0,l/2,an)
            shape2.beginClip()
                circone.init(an*2)
            shape2.endClip()
           shape2.image(sh1,-l/2,-l/2) 
           shape2.pop()   
});

 shapes.set(0.109, (n, d, tr, an, x, y) => {
     var title = "clip with water drop / ortogonal cone";
     var l = min(width, height);
     shape2 = createGraphics(l, l, WEBGL);
     const wh = { w: img[org].width, h: img[org].height };
    const t = rectToSquare(wh, x, y, d)
    var sh1 = img[org].get(t.tl.x, t.tl.y, t.w, t.w)
   //var sh1=img[org].get(x,y,x+l,y+l)
    shape2.clear()
    shape2 = createGraphics(l, l, WEBGL);
    var petal = true;
    if (floor(d) % 2 == 0) { petal = false; }
    shape2.push();
    var circone= new Circone(0,-l/2,0,l/2,an*2)
    shape2.beginClip()
        circone.init(an*2)
    shape2.endClip()
   shape2.image(sh1,-l/2,-l/2,l,l) 
   shape2.pop()   
});

/////
        shapes.set(1.1, (n, d, tr, an, x, y) => {
            var title = "spiral points";
            var l = min(width, height);
            shape2 = createGraphics(l * 2, l * 2);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var numVertices = 1800;
            var angle = 0.30;
            var offset = width * 1;
            var scalar = 6;
            var speed = 0.3;
            if (d > 0.01) {
                scalar = an * n * 2
                speed = 180 / d;
            }
            var direction = 1
            if (int(d % 2) == 0) { direction = -1 }
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = 0;
            var dy = 0;
            while (dx < l * 2 * sqrt(2) && dy < l * 2 * sqrt(2)) {
                coli = img[org].get(contx, conty)
                dx = offset + cos(angle) * scalar;
                dy = offset + sin(angle) * scalar;
                dcenter = dist(dx, dy, offset, offset)
                var rade = map(dcenter, 0, width, 8, 55)
                shape2.fill(coli)
                shape2.stroke(coli)
                //cutShape(org, dx, dy, 1, rade, d, an = 1)
                shape2.ellipse(dx, dy, rade, rade);
                if (direction == -1) { angle -= speed; } else {
                    angle += speed;
                }
                scalar += speed;
                contx += 1
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(1.2, (n, d, tr, an, x, y) => {
            var title = "concentrics circles";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = l * 2 * sqrt(2);
            var dy = l * 2 * sqrt(2);
            while (dx > 0 && dy > 0) {
                coli = img[org].get(contx, conty)
                shape2.fill(coli)
                shape2.stroke(coli)
                shape2.ellipse(l / 2, l / 2, dx, dy);
                dx = dx - 1;
                dy = dy - 1;
                contx += 1
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            //image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(1.3, (n, d, tr, an, x, y) => {
            var title = "concentrics circles with points";
            var l = min(width, height);
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.push();
            var coli;
            var contx = x;
            var conty = y;
            var dcenter = 0;
            var dx = l * 1 * sqrt(2);
            var dy = l * 1 * sqrt(2);
            var mod = TWO_PI / n
            var mode = 8
            var px = 0
            var py = 0
            var ann = 0
            var dw = 30
            while (dx > 0 && dy > 0) {

                //shape2.ellipse(l/2,l/2, dx, dy);
                //ann+=an
                ann = 0
                dw = dist(dx, dy, 0, 0)
                coli = img[org].get(contx, conty)
                shape2.fill(coli)
                shape2.stroke(coli)
                for (var a = 0; a < n; a++) {

                    px = l / 2 + dx * cos(ann)
                    py = l / 2 + dy * sin(ann)
                    shape2.ellipse(px, py, dw / 2, dw / 2);
                    contx += 1

                    ann += mod
                }
                dx = dx - 8;
                dy = dy - 8;
                conty += 1
                if (contx > img[org].width) { contx = x }
                if (conty > img[org].height) { conty = y }
            }

            //image(shape2, 0, 0);
            shape2.pop();
        });





        shapes.set(1.5, (n, d, tr, an, x, y) => {
            var title = "rect pattern points";
            var l = min(width, height);
            const wh = { w: img[org].width, h: img[org].height };

            var nn = 0;
            var nnn = floor(d) % 2
            if (nnn == 0) { nn = 16 }
            if (nnn == 1) { nn = 32 }
            //if(nnn==2){nn=32}

            const t = rectToSquare(wh, x, y, d)
            var rade = l / nn;
            var pade = t.w / nn;
            shape2 = createGraphics(l, l);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            var cx = 0
            var cy = 0
            var geti = img[org].get(t.tl.x, t.tl.y, t.w, t.w)


            for (var b = 0; b < l; b += rade) {
                for (var a = 0; a < l; a += rade) {
                    var col = geti.get(cx, cy)
                    var light = lightness(col);
                    var radius = map(light, 0, 255, 3, pade * 1);
                    //shape2.fill(0);
                    //shape2.ellipse(a, b, 40);
                    shape2.fill(col);
                    shape2.ellipse(a, b, radius);
                    cx += pade
                }
                cx = 0
                cy += pade
            }
            /*
        shape2.fill(199,0,0)
            shape2.ellipse(0,0,100,100)
            shape2.fill(199,100,0)
            shape2.ellipse(width,height,100,100)
*/
            image(shape2, 0, 0);
        });

        shapes.set(1.6, (n, d, tr, an, x, y) => {
            var title = "shape along curve";
            var l = min(width, height);
            shapes.get(0.61).apply(null, [n * 2, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            shape2.clear()
            var wx = map(x, 0, img[org].width, 0, l)
            var wy = map(y, 0, img[org].height, 0, l)
            let p1 = { x: -l / 2, y: -l / 2 }
            let p2 = { x: wx, y: -wy }
            let p3 = { x: -wx, y: wy }
            let p4 = { x: l / 2, y: l / 2 }
            for (let i = 0; i < 100; i++) {
                let pt = bez(i / 100, p1, p2, p3, p4);
                let dx = pt.x - pr.x;
                let dy = pt.y - pr.y;
                if (i % 2 === 0 && i !== 0) {
                    let th = atan2(pt.y + dx * 50 - pt.y, pt.x - dy * 50 - pt.x)
                    shape2.noStroke()
                    shape2.push()
                    shape2.translate(pt.x, pt.y)
                    shape2.rotate(th)
                    shape2.translate(0, 0)
                    shape2.fill(255, 200, 0)
                    shape2.texture(img2)
                    shape2.rect(0, 0, l, l)
                    //shape2.image(img2,0,0)
                    shape2.pop()
                }
                pr.x = pt.x;
                pr.y = pt.y;
            }
        });

        shapes.set(1.7, (n, d, tr, an, x, y) => {
            var title = "H cenefa";
            var l = min(width, height);
            shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            let v1 = l / n
            let v2 = v1 / 2
            shape2.clear()
            img2.resize(v1, v1)
            shape2.push()
            shape2.translate(0, -v2)
            shape2.image(img2, 0, 0)
            for (var a = 0; a < n / 2; a++) {
                shape2.translate(-v1, 0)
                shape2.image(img2, 0, 0)
            }
            shape2.pop()
            shape2.push()
            shape2.translate(v1, -v2)
            shape2.image(img2, 0, 0)
            for (a = 0; a < (n / 2) - 1; a++) {
                shape2.translate(v1, 0)
                shape2.image(img2, 0, 0)
            }
            shape2.pop()
        });
        shapes.set(1.8, (n, d, tr, an, x, y) => {
            var title = "Flower mandala object";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l / 6;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            flower.init();
        });
        shapes.set(1.9, (n, d, tr, an, x, y) => {
            var title = "Flower object";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l / 2;
            var petal = true;
            var na = [3, 4, 5, 6, 7, 8, 7, 10, 11, 12]
            var np = na[floor(d) % 10]
            if (floor(d) % 2 == 0) { petal = false }
            shape2.noStroke()
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            flower.polen(0, 0, np, r, n, petal, 0);
        });
        shapes.set(1.11, (n, d, tr, an, x, y) => {
            var title = "Flower object";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l * 0.8;
            var difi = (l - r) / 2
            var roti = PI / 6
            if (floor(an * 1000) % 2 == 0) { roti += PI }
            var petal = true;
            if (floor(d) % 2 == 0) {
                petal = false;
                roti = -PI / 6;
            }
            shape2.noStroke()
            var imad = PI / 6;
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var x0 = -width / 2 + difi;
            var y0 = 0;
            var x1 = x0 + r * cos(-imad);
            var y1 = y0 + r * sin(-imad);
            var x2 = x0 + r * cos(imad);
            var y2 = y0 + r * sin(imad);
            shape2.push()
            shape2.rotate(roti)
            flower.trilen(x0, y0, x1, y1, x2, y2, n, petal, 0)
            shape2.pop()
        });
        shapes.set(1.12, (n, d, tr, an, x, y) => {
            var title = "Flower box";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            if (n > 22) { n = 2 }
            var r = l / 6;
            var r3 = r * 3;
            var petal = true;
            if (floor(d) % 2 == 0) { petal = false; }
            var flower = new Flower(0, 0, x, y, d, r, n, petal);
            var coa = [...flower.aco[1]]
            var inp = { x: 0, y: 0 }
            flower.flowbox(1, inp, 0, r3, coa);
            flower.flowbox(2, inp, 0, r3, coa);
            flower.flowbox(3, inp, 0, r3, coa);
            //flower.flowbox(4, 0, 0, r3);
            //flower.init();
            flower.flowbox(1, inp, 0, r, coa);
            flower.flowbox(1, inp, 1, r, coa);
            flower.flowbox(1, inp, 2, r, coa);
            flower.flowbox(1, inp, 3, r, coa);
            flower.flowbox(10, inp, 3, r, coa);
            flower.flowbox(7, inp, 4, r, coa);
            flower.flowbox(7, inp, 5, r, coa);
            flower.flowbox(10, inp, 4, r, coa);
            flower.flowbox(12, inp, 5, r, coa);
            flower.flowbox(9, inp, 6, r, coa);
            flower.flowbox(12, inp, 6, r, coa);
            flower.flowbox(9, inp, 1, r, coa);
            flower.flowbox(4, inp, 2, r, coa);

        });



        shapes.set(2.1, (n, d, tr, an, x, y) => {
            var title = "Sun and floor";
            var l = min(width, height);
            shapes.get(3.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            shape2.image(geta, -l / 2, -l / 2)
            shape2.push()
            shape2.translate(0, l / 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
        });

        shapes.set(2.11, (n, d, tr, an, x, y) => {
            var title = "Sun and floor -  sketch";
            var l = min(width, height);
            shapes.get(3.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()

            const vert = getPlaneMidSide(l * 2, l * 8)
            shape2 = createGraphics(l, l, WEBGL);
            shape2.image(geta, -l / 2, -l / 2)
            shape2.push()
            shape2.translate(0, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            //shape2.texture(gete)
            //pe2.translate(0,l/2)
            //shape2.image(gete,-l/2,-l/2)

            shape2.pop()
        });

        shapes.set(2.2, (n, d, tr, an, x, y) => {
            var title = "mask image with noise";
            var l = min(width, height);
            shape2 = createGraphics(width, height, WEBGL);

            if (floor(d) % 2 == 0) {
                cutSquare(org, x, y, 0, l, d / 2);
                shape2.tint(100, 150)
            } else {
                let giti = img[org].get(x, y)
                fill(giti)
                rect(-l / 2, -l / 2, l, l)
            }
            shape2.push();
            shape2.smooth();
            shape2.clip(() => {
                shape2.stroke(0);
                shape2.fill(0);
                shape2.beginShape()
                shape2.vertex(-l / 2, l / 2)

                for (let xi = -l / 2; xi < l / 2; xi++) {
                    let noiseOffset = n / 100;
                    let noiseVal = noise(noiseOffset + xi / 100);
                    shape2.vertex(xi, noiseVal * 100 - 100);
                }
                shape2.vertex(l / 2, l / 2)
                shape2.endShape()
            });

            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);
            cutSquare(org, x, y, 0, l, d);
            shape2.pop();
            shape2.pop();
        });
        shapes.set(3.1, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            var cutname = 1;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 4 + tr.trx, height * 0 / 4 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            shape2 - cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.2, (n, d, tr, an, x, y) => {
            var title = "symmetry regular triangle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            var cutname = 2;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();
            shape2.push();
            shape2.rotate(HALF_PI + HALF_PI / 3);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();
            shape2.push();
            shape2.rotate(-HALF_PI - HALF_PI / 3);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, cutname, l, d);
            shape2.pop();
            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.21, (n, d, tr, an, x, y) => {
            var title = "pattern triangle";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            shapes.get(3.2).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shape2.clear()
            shape2.image(geta, -l / 2, -l / 2, l, l)


            shape2.push()
            shape2.rotate(PI)
            ax = l / 2 * cos(PI / 6)
            ay = l / 2 * sin(PI / 6)
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 2, -l / 2, l, l)
            shape2.pop()

            shape2.push()
            shape2.rotate(PI)
            ax = l / 2 * cos(PI / 6)
            ay = l / 2 * sin(PI / 6)
            shape2.translate(-ax, ay)
            shape2.image(geta, -l / 2, -l / 2, l, l)
            shape2.pop()


            var ssidet = l / 2 - sidet
            var icu = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.beginClip()
            //shape2.rect(-(l/2)+l/16,-l/2,(l)-l/8,l)
            shape2.rect(-(l / 2) + ssidet, -l / 2, sidet * 2, l)
            shape2.endClip()
            shape2.image(icu, -l / 2, -l / 2)

        });


        shapes.set(3.22, (n, d, tr, an, x, y) => {
            var title = "vertical symmetry from triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shapes.get(3.21).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = sidet;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)

            ax = -sidet * 2;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            shape2.pop()

            shape2.push()
            shape2.scale(1, -1)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = sidet;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            ax = -sidet * 2;
            ay = 0;
            shape2.translate(ax, ay)
            shape2.image(geta, -l / 4, 0, l / 2, l / 2)
            shape2.pop()
            if (floor(d) % 2 == 0) {
                var gete = shape2.get(0, 0, l, l)
                shape2.clear()
                shape2.image(gete, -l / 2, -l / 2)
                shape2.push()
                ax = 0;
                ay = l - (l / 4)
                shape2.translate(ax, ay)
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
                shape2.push()
                ax = 0;
                ay = -l + (l / 4)
                shape2.translate(ax, ay)
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
            }
        });

        shapes.set(3.23, (n, d, tr, an, x, y) => {
            var title = "vertical symmetry from triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2 / sqrt(3)) / 2
            shapes.get(3.22).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);

            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()

            if (floor(d) % 2 == 0) {
                shape2.image(geta, -l / 2, -l / 2)
            } else {
                shape2.image(geta, -l / 2, -l / 2, l, l)
            }
            shape2.pop()
        });
        shapes.set(3.24, (n, d, tr, an, x, y) => {
            var title = "rotated triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2.1 / sqrt(3)) / 2
            //var sideh = sidet * sqrt(3) /2
            var sideh = (l / 2.5)
            //shape2.imageMode(CENTER); 
            var dd = 0
            if (floor(d) % 2 == 0) { dd = d + 1 } else { dd = d }
            shapes.get(3.2).apply(null, [n, dd, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var si1 = (sqrt(3) / 2)
            var si2 = (l / 4) * si1
            var pro1 = (2 / sqrt(3)) * 1
            var pro2 = (l / 4) * pro1
            var pro3 = pro2 * 0.5
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            geta.resize(l / 3, l / 3)

            shape2.push()

            shape2.rotate(PI / 6)
            for (var a = 0; a < 6; a++) {
                shape2.rotate(PI / 3)
                shape2.push()
                shape2.translate((-l / 6), 0)
                shape2.image(geta, 0, 0)
                shape2.pop()
            }
            shape2.pop()

            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()
            for (var a = 0; a < 6; a++) {
                shape2.push()
                if (a % 2 == 0) {
                    shape2.translate(0, pro2)
                }
                if (a % 2 == 1) {
                    shape2.translate(0, pro2 * 2)
                }
                if (a % 3 == 2) {
                    //shape2.translate(0,pro2*4)
                }
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
                shape2.rotate(TWO_PI / 6)
            }
            shape2.pop()


            shape2.push()
            shape2.translate((l / 6) * 1.5, pro2 * 2.5)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate(-(l / 6) * 1.5, pro2 * 2.5)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate(-(l / 6) * 3, -pro2 * 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate((l / 6) * 3, -pro2 * 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()


            //shape2.ellipse(0,0,9,9) 

        });

        shapes.set(3.241, (n, d, tr, an, x, y) => {
            var title = "rotated triangle pattern";
            var l = min(width, height);
            var ax = 0
            var ay = 0
            var sidet = (((l / 4) * 3) * 2.1 / sqrt(3)) / 2
            //var sideh = sidet * sqrt(3) /2
            var sideh = (l / 2.5)
            //shape2.imageMode(CENTER); 
            var dd = 0
            if (floor(d) % 2 == 0) { dd = d + 1 } else { dd = d }
            shapes.get(3.2).apply(null, [n, dd, { scl: 0.5, rtt: PI / n, trx: 0, try: 0 }, an, x, y]);
            var si1 = (sqrt(3) / 2)
            var si2 = (l / 4) * si1
            var pro1 = (2 / sqrt(3)) * 1
            var pro2 = (l / 4) * pro1
            var pro3 = pro2 * 0.5
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            geta.resize(l / 3, l / 3)

            shape2.push()

            shape2.rotate(PI / 6)
            for (var a = 0; a < 6; a++) {
                shape2.rotate(PI / 3)
                shape2.push()
                shape2.translate((-l / 6), 0)
                shape2.image(geta, 0, 0)
                shape2.pop()
            }
            shape2.pop()

            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2.push()
            for (var a = 0; a < 6; a++) {
                shape2.push()
                if (a % 2 == 0) {
                    shape2.translate(0, pro2)
                }
                if (a % 2 == 1) {
                    shape2.translate(0, pro2 * 2)
                }
                if (a % 3 == 2) {
                    //shape2.translate(0,pro2*4)
                }
                shape2.image(gete, -l / 2, -l / 2)
                shape2.pop()
                shape2.rotate(TWO_PI / 6)
            }
            shape2.pop()


            shape2.push()
            shape2.translate((l / 6) * 1.5, pro2 * 2.5)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate(-(l / 6) * 1.5, pro2 * 2.5)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate(-(l / 6) * 3, -pro2 * 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()
            shape2.push()
            shape2.translate((l / 6) * 3, -pro2 * 2)
            shape2.image(gete, -l / 2, -l / 2)
            shape2.pop()


            //shape2.ellipse(0,0,9,9) 

        });

        shapes.set(3.25, (n, d, tr, an, x, y) => {
            var title = "H triangle pattern";
            var l = min(width, height);
            shapes.get(3.24).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            let img2 = shape2.get(0, 0, l, l)
            pr = { x: 0, y: 0 }
            n = 2
            let v1 = l / n
            let v2 = v1 / 2
            shape2.clear()
            img2.resize(v1, v1)
            shape2.push()
            shape2.translate(0, -v2)
            shape2.image(img2, 0, 0)
            for (var a = 0; a < n / 2; a++) {
                shape2.translate(-v1, 0)
                shape2.image(img2, 0, 0)
            }
            shape2.pop()

            shape2.push()
            shape2.translate(v1, -v2)
            shape2.image(img2, 0, 0)
            for (a = 0; a < (n / 2) - 1; a++) {
                shape2.translate(v1, 0)
                shape2.image(img2, 0, 0)
            }
            shape2.pop()


            shape2.push()
            shape2.translate(-v1 / 4, -v1 - v2)
            shape2.image(img2, 0, 0)
            shape2.translate(-v1, 0)
            shape2.image(img2, 0, 0)
            shape2.translate(v1 * 2, 0)
            shape2.image(img2, 0, 0)
            shape2.pop()

            shape2.push()
            shape2.translate(-v1 / 4, v2)
            shape2.image(img2, 0, 0)
            shape2.translate(-v1, 0)
            shape2.image(img2, 0, 0)
            shape2.translate(v1 * 2, 0)
            shape2.image(img2, 0, 0)
            shape2.pop()


        });

        shapes.set(3.3, (n, d, tr, an, x, y) => {
            var title = "symmetry arrow from regular triangle aperture";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var x = 33; //random(width);
            var y = 33 + random(0, 25); //random(height);
            var g = HALF_PI;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, 4, l, d, an);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, 4, l, d, an);

            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.4, (n, d, tr, an, x, y) => {
            var title = "symmetry from isosceles triangle aperture";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var g = HALF_PI;
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            shape2.push();
            cutTriangle(org, x, y, 5, l, d, an);
            shape2.scale(-1, 1);
            cutTriangle(org, x, y, 5, l, d, an);

            shape2.pop();

            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(3.5, (n, d, tr, an, x, y) => {
            var title = "sector circle and repeat n times with symm";
            var l = min(width, height);
            shape2 = createGraphics(l * 1, l * 1, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();

            //shape2.scale(tr.scl, tr.scl);
            shape2.scale(0.5, 0.5);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);


            //shape2.translate(450,450)
            var ang = TWO_PI / n;
            for (var a = 0; a < floor(n / 2); a++) {
                shape2.rotate(ang * 2);
                shape2.push();
                cutTriangle(org, x, y, 6, l, d, ang);
                shape2.scale(-1, 1);
                shape2.rotate(PI - ang * 2);
                cutTriangle(org, x, y, 6, l, d, ang);
                shape2.pop();
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.51, (n, d, tr, an, x, y) => {
            var title = "sector circle and repeat n times with symm overflow";
            var l = min(width, height);
            shape2 = createGraphics(l * 1, l * 1, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();

            //shape2.scale(tr.scl, tr.scl);
            shape2.scale(0.5, 0.5);
            shape2.rotate(tr.rtt);
            shape2.translate(tr.trx, tr.try);


            //shape2.translate(450,450)
            var ang = TWO_PI / n;
            for (var a = 0; a < floor(n / 2); a++) {
                shape2.rotate(ang * 2);
                shape2.push();
                cutTriangle(org, x, y, 6.1, l, d, ang);
                shape2.scale(-1, 1);
                shape2.rotate(PI - ang * 2);
                cutTriangle(org, x, y, 6.1, l, d, ang);
                shape2.pop();
            }
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(3.6, (n, d, tr, an, x, y) => {
            var title = "symmetry triangles in circle";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt - HALF_PI);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = TWO_PI / n;
            var dx, dy
            var ofsset = 49
            var scalar = l
            //var angi=ang*2
            var angi = TWO_PI / n
            for (var a = 0; a < n; a++) {
                shape2.push()
                cutTriangle(org, x, y, 10, scalar, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutTriangle(org, x, y, 10, scalar, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            shape2.pop();
            image(shape2, 0, 0);
        });


        /////////////////

        shapes.set(4.1, (n, d, tr, an, x, y) => {
            var title = "square sym";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, 1, l, d, null)
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 1, l, d, null)
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(4.2, (n, d, tr, an, x, y) => {
            var title = "square sym";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var d2 = random(height / 2);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            cutSquare(org, x, y, 2, l, d, d2)
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 2, l, d, d2)
            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.3, (n, d, tr, an, x, y) => {
            var title = "diamond sector circular, star";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = TWO_PI / n;
            for (var a = 0; a < n; a++) {
                shape2.push();
                cutTriangle(org, x, y, 7, l, d, ang + (ang * 0));
                shape2.scale(-1, 1);
                shape2.rotate(PI - (ang * 2) * 1);
                cutTriangle(org, x, y, 7, l, d, ang + (ang * 0));
                shape2.pop();
                shape2.rotate(ang * 2);
            }
            //shape2.image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.4, (n, d, tr, an, x, y) => {
            var title = "grid on square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, -1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            image(shape2, 0, 0);
            shape2.pop();
        });

        shapes.set(4.5, (n, d, tr, an, x, y) => {
            var title = "2 triangles in quart square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            shape2.textureWrap(MIRROR);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            var td = l / 2

            shape2.push()
            shape2.translate(-td, -td)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            //shape2.rotate(-ang * 1);
            //shape2.scale(-1, -1);0

            shape2.push()
            shape2.translate(td * 1, td * 1)
            shape2.scale(-1, -1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            shape2.push()

            shape2.translate(-td, td)
            shape2.scale(1, -1)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()

            shape2.push()
            shape2.translate(td, -td)
            shape2.scale(-1, 1)
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.scale(-1, 1);
            shape2.rotate(-ang * 1);
            cutTriangle(org, x, y, 9, l, d, ang);
            shape2.pop()
            image(shape2, 0, 0);
            shape2.pop();
        });
        shapes.set(4.51, (n, d, tr, an, x, y) => {
            var l = min(width, height);
            shapes.get(4.5).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();
        });

        shapes.set(4.6, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            var angi = TWO_PI / n;
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var longr = l

            for (var a = 0; a < n; a++) {
                shape2.push()
                cutSquare(org, x, y, 4, longr, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutSquare(org, x, y, 4, longr, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            pop();
            image(shape2, 0, 0);
        });
        shapes.set(4.61, (n, d, tr, an, x, y) => {
            var title = "symmetry triangle in square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt - HALF_PI);
            translate(width / 2 + tr.trx, height / 2 + tr.try);
            var longr = l
            var angi = TWO_PI / n;
            for (var a = 0; a < n; a++) {
                shape2.push()
                cutSquare(org, x, y, 5, longr, d, angi);
                shape2.scale(-1, 1);
                shape2.rotate(PI - (angi * 2));
                cutSquare(org, x, y, 5, longr, d, angi);
                shape2.pop();
                shape2.rotate(angi * 2);
            }
            pop();
            image(shape2, 0, 0);
        });
        shapes.set(4.62, (n, d, tr, an, x, y) => {
            var title = "concentric rings";
            var l = min(width, height);
            /*   shape2 = createGraphics(l, l, WEBGL);
               push();
               shape2.scale(tr.scl, tr.scl);
               shape2.rotate(tr.rtt - HALF_PI);
               translate(width / 2 + tr.trx, height / 2 + tr.try);
               var longr = l
               var angi = TWO_PI / n;
               for (var a = 0; a < n; a++) {
                   shape2.push()
                   cutSquare(org, x, y, 5, longr, d, angi);
                   shape2.scale(-1, 1);
                   shape2.rotate(PI - (angi * 2));
                   cutSquare(org, x, y, 5, longr, d, angi);
                   shape2.pop();
                   shape2.rotate(angi * 2);
               }
               pop();
               */
            //image(shape2, 0, 0);
            shapes.get(4.61).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            //shapes.get(4.61).apply(null, [n, d+10, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x+10, y+10]); 

            //var geti = shape2.get(0, 0,l, l)
            //shape2.clear()  
            ///////////////////
            //var sz = 1
            //sz = floor(d) % 5 + 2
            //shape2.image(geta,-l / 2, -l / 2 , l / sz, l / sz)
            var n1 = 1;
            var n2 = 2
            /*shape2.image(geta,-l*2 , -l*2, l*4,l*4 )
            shape2.image(geta,-l , -l, l*2,l*2 )
            shape2.image(geta,-l/2 , -l/2, l,l )
            shape2.image(geta,-l/4 , -l/4, l/2,l/2 )
            shape2.image(geta,-l/8 , -l/8, l/4,l/4 )
            */
            shape2.image(geta, -l * 2, -l * 2, l * 4, l * 4)
            let roti = TWO_PI / n;
            shape2.push()
            for (var a = 1; a < 7; a++) {
                //if(a%2==0){
                shape2.rotate(roti)
                shape2.image(geta, -l * (1 / n1), -l * (1 / n1), l * n2, l * n2)
                //}else{
                //shape2.image(geti,-l*(1/n1), -l*(1/n1), l*n2,l*n2 )
                //}
                n1 = n1 * 2
                n2 = n2 / 2
            }
            shape2.pop()
        });
        shapes.set(4.7, (n, d, tr, an, x, y) => {
            var title = "grid on square";
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            tr.rtt += -HALF_PI;
            //random(height);
            shape2.push();
            shape2.scale(tr.scl, tr.scl);
            shape2.rotate(tr.rtt);
            shape2.translate(width * 0 / 2 + tr.trx, height * 0 / 2 + tr.try);
            var ang = HALF_PI;
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, -1);
            cutSquare(org, x, y, 3, l, d, ang);
            shape2.scale(-1, 1);
            cutSquare(org, x, y, 3, l, d, ang);
            image(shape2, 0, 0);
            shape2.pop();
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();

        });

        shapes.set(4.71, (n, d, tr, an, x, y) => {
            var title = 'square patttern'
            var l = min(width, height);
            shapes.get(4.7).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var geta = shape2.get(0, 0, l, l)
            shape2.clear()
            ///////////////////
            var sz = 1
            sz = floor(d) % 5 + 2
            shape2.image(geta, -l / 2, -l / 2, l / sz, l / sz)
            var geti = shape2.get(0, 0, l / sz, l / sz)
            shape2.clear()
            var xy = l / sz
            //shape2.image(geti,-l/2,-l/2)
            ///////////////////////////////
            shape2.push();
            shape2.translate(-l / 2, -l / 2)
            var cx = 0;
            cy = 0
            for (var b = 0; b < sz; b++) {
                for (var a = 0; a < sz; a++) {
                    shape2.push()
                    shape2.translate(cx, cy)
                    shape2.image(geti, 0, 0)
                    shape2.pop()
                    cx += xy
                    //shape2.image(geti,a,b)
                }
                cx = 0
                cy += xy
            }
            shape2.pop();
        });
        shapes.set(5.0, (n, d, tr, an, x, y) => {
            var title = 'tetrahedrom spheres color'
            var l = min(width, height);
            let coln
            let vert = getTetraVert(l * sqrt(2)) //2*sqrt(2)
            shape2 = createGraphics(l, l, WEBGL);

            coln = img[org].get(x, y)
            //shape2.ambientLight(60, 60, 60);

            shape2.specularMaterial(red(coln) * 0.1);

            shape2.pointLight(red(coln), green(coln), blue(coln), l * 118, -l * 122, l * 118);
            shape2.directionalLight(0, green(coln), blue(coln), 0, 0, -l * 100)


            for (var a = 0; a < 12; a++) {
                shape2.push()
                shape2.translate(0, 0, -l * 2 * a + 1)
                shape2.rotate(an + a)

                for (let i = 0; i < vert.length; i++) {
                    var colx = x + d * cos(an * i)
                    coln = img[org].get(colx, y + i + a)
                    shape2.noStroke()
                    shape2.push()
                    shape2.ambientMaterial(red(coln), green(coln), blue(coln));
                    shape2.emissiveMaterial(red(coln) * 0.1, green(coln) * 0.1, blue(coln) * 0.1)
                    shape2.shininess(lightness(coln));
                    shape2.translate(vert[i].x, vert[i].y, vert[i].z)
                    shape2.fill(coln)
                    shape2.rotate(an * n + i)
                    shape2.sphere(l * 2 / n)
                    //shape2.ellipse(0,0, l,l)
                    //shape2.image(img2,0,0)
                    shape2.pop()
                }
                shape2.pop()
            }

        });
        shapes.set(5.1, (n, d, tr, an, x, y) => {
            var title = 'tetrahedrom photo and lines'
            var l = min(width, height);
            let vert = getTetraVert(l * sqrt(2)) //2*sqrt(2)
            //shapes.get(0.4).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            //shapes.get(4.7).apply(null, [4, l, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            shape2 = createGraphics(l, l, WEBGL);
            //let sh=shape2.get(0,0,l,l)
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            if (int(d) % 2 == 0) {
                vert.sort(compareZ);
            }
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            //shape2.clear()
            let coln = img[org].get(x, y)
            // shape2.specularMaterial(red(coln)*0.1);
            // shape2.pointLight(red(coln),green(coln),blue(coln), l*118, -l*122, l*118);
            //shape2.directionalLight(0,green(coln),blue(coln),0,0,-l*100)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            shape2.rotate(an)
            var wei = l * 4 / n / 6
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            for (let i = 0; i < vert.length; i++) {

                coln = imgs[i].get(colx, coly)


                shape2.push()
                //shape2.ambientMaterial(red(coln),green(coln),blue(coln));
                //shape2.emissiveMaterial(red(coln)*0.1,green(coln)*0.1,blue(coln)*0.1)
                //shape2.shininess(lightness(coln));
                shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
                shape2.texture(imgs[i])
                //shape2.rotate(blue(coln))
                shape2.ellipse(0, 0, l * 4 / n, l * 4 / n)
                //shape2.sphere(l*1/n)

                //shape2.ellipse(0,0, l,l)
                //shape2.image(img2,0,0)
                shape2.pop()

                if (i < vert.length - 1) {
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                    shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                    shape2.endShape();

                } else {
                    //shape2.noStroke() 
                    //shape2.texture(imgs[i])
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[0].x, vert[0].y, vert[0].z);
                    shape2.vertex(vert[2].x, vert[2].y, vert[2].z);
                    shape2.endShape();
                }

                shape2.noStroke()

            }
            for (i = 0; i < vert.length; i++) {

                //coln=imgs[i].get(colx,coly)

            }
            shape2.pop()
        });

        shapes.set(5.2, (n, d, tr, an, x, y) => {
            var title = 'Box photo interior'
            var l = min(width, height);
            shape2 = createGraphics(l, l, WEBGL);
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            let anr = 0
            var wei = l * 4 / n / 6
            let vert = getBoxVert(l * 1.2 - wei * 0, l * 4)
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }

            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            var edgi = vert[0]
            cut3D(imgs[0], x, y, 1, 100, d, an, [vert[edgi.edge[1]], vert[edgi.face], vert[0], vert[edgi.edge[0]]])
            edgi = vert[1]
            cut3D(imgs[1], x, y, 1, 100, d, an, [vert[1], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            edgi = vert[3]
            cut3D(imgs[3], x, y, 1, 100, d, an, [vert[3], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            edgi = vert[2]
            cut3D(imgs[2], x, y, 1, 100, d, an, [vert[2], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            cut3D(imgs[4], x, y, 1, 100, d, an, [vert[7], vert[6], vert[4], vert[5]])
            if (floor(d) % 2 == 0) {
                var colni = imgs[0].get(colx, coly)
                for (let i = 0; i < vert.length; i++) {
                    coln = imgs[i].get(colx, coly)
                    for (var a = 0; a < vert[i].edge.length; a++) {
                        shape2.strokeWeight(wei)
                        shape2.stroke(colni)
                        shape2.beginShape();
                        shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                        edgi = vert[i].edge[a]
                        shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
                        //shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                        shape2.endShape();
                    }
                    shape2.noStroke()
                }
            }
            shape2.pop()
        });
        shapes.set(5.21, (n, d, tr, an, x, y) => {
            var title = 'Box photo interior floor pattern'
            var l = min(width, height);
            var suelo = [0, -0.14, 3.51, 4.51, -0.141]
            var soli = floor(d) % 5;
            if (soli > 0) {
                shapes.get(suelo[soli]).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
                var geta = shape2.get(0, 0, l, l)
            }
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            let anr = 0
            var wei = l * 4 / n / 6
            let vert = getBoxVert(l * 1.2 - wei * 0, l * 4)
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }

            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            var edgi = vert[0]
            //cut3D(imgs[0], x, y, 1, 100, d, an, [vert[0],vert[edgi.edge[0]],vert[edgi.edge[1]],vert[edgi.face]])
            if (soli == 0) {
                cut3D(imgs[0], x, y, 1, 100, d, an, [vert[edgi.edge[1]], vert[edgi.face], vert[0], vert[edgi.edge[0]]])
            } else {
                cut3D(geta, x, y, 1, 100, d, an, [vert[edgi.edge[1]], vert[edgi.face], vert[0], vert[edgi.edge[0]]])
            }
            edgi = vert[1]
            cut3D(imgs[1], x, y, 1, 100, d, an, [vert[1], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            edgi = vert[3]
            cut3D(imgs[3], x, y, 1, 100, d, an, [vert[3], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            edgi = vert[2]
            cut3D(imgs[2], x, y, 1, 100, d, an, [vert[2], vert[edgi.edge[0]], vert[edgi.edge[1]], vert[edgi.face]])
            //if(soli<2){
            cut3D(imgs[4], x, y, 1, 100, d, an, [vert[7], vert[6], vert[4], vert[5]])
            //}else{
            //cut3D(geta, x, y, 1, 100, d, an, [vert[7],vert[6],vert[4],vert[5]]) 
            //}
            if (floor(d) % 2 == 0) {
                var colni = imgs[0].get(colx, coly)
                for (let i = 0; i < vert.length; i++) {
                    coln = imgs[i].get(colx, coly)
                    for (var a = 0; a < vert[i].edge.length; a++) {
                        shape2.strokeWeight(wei)
                        shape2.stroke(colni)
                        shape2.beginShape();
                        shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                        edgi = vert[i].edge[a]
                        shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
                        //shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                        shape2.endShape();
                    }
                    shape2.noStroke()
                }
            }
            shape2.pop()
        });
        shapes.set(5.22, (n, d, tr, an, x, y) => {
            var title = 'Cubeoctahedron'
            var l = min(width, height);
            //shapes.get(3.6).apply(null, [n, d, { scl: 0.5, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            //var geta=shape2.get(0,0,l,l)
            //geta.resize(l/4,l/4)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            //let sh=shape2.get(0,0,l,l)
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            //var wei = l * 4 / n / 6
            var wei = (l / 30)
            //let vert = getBoxData(l*1.2-wei*0, l * 4)
            let vert = getBoxData(l * 1.2, l * 0.5)
            //for (var j = 0; j < vert.length; j++) {
            for (var j = 0; j < 4; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            let coln = img[org].get(x, y)
            shape2.push()

            shape2.translate(0, 0, -l * 1)
            if (floor(d) % 2 == 0) {
                //shape2.rotateY(an)
            } else {
                //shape2.rotateY(0)
            }
            //shape2.rotate(anr)            
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            var colni = imgs[0].get(colx, coly)
            //for (let i = 0; i < vert.length; i++) {
            //-->coln = imgs[i].get(colx, coly)
            //-->shape2.push()
            //-->shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
            //shape2.texture(imgs[i])
            //-->shape2.fill(coln)
            //-->shape2.ellipse(0, 0, wei,  wei)
            //shape2.ellipse(0, 0, wei*2,  wei*2)
            //rect(0,0,30,30)
            //shape2.image(geta,-l/4,-l*4)
            //-->shape2.pop()
            //for(var a=0;a<vert[i].edge.length;a++){
            let edga = 0
            let edge = 0
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            edga = facel[0][0][0]
            edge = facel[0][0][1]
            facel[0][0][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[0][1][0]
            edge = facel[0][1][1]
            facel[0][1][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            //line31(vert,facel[0][0][2],facel[0][1][2])
            edga = facel[0][2][0]
            edge = facel[0][2][1]
            facel[0][2][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[0][3][0]
            edge = facel[0][3][1]
            facel[0][3][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)

            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            edga = facel[5][0][0]
            edge = facel[5][0][1]
            facel[5][0][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[5][1][0]
            edge = facel[5][1][1]
            facel[5][1][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[5][2][0]
            edge = facel[5][2][1]
            facel[5][2][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[5][3][0]
            edge = facel[5][3][1]
            facel[5][3][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            edga = facel[6][0][0]
            edge = facel[6][0][1]
            facel[6][0][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[6][1][0]
            edge = facel[6][1][1]
            facel[6][1][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[6][2][0]
            edge = facel[6][2][1]
            facel[6][2][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            edga = facel[6][3][0]
            edge = facel[6][3][1]
            facel[6][3][2] = mpoint2(vert, edga, edge)
            shape2.strokeWeight(wei)
            shape2.stroke(colni)
            //line3(vert,edga,edge)
            let k = 5

            line31(vert, facel[k][0][2], facel[k][1][2])
            line31(vert, facel[k][1][2], facel[k][2][2])
            line31(vert, facel[k][2][2], facel[k][3][2])
            line31(vert, facel[k][3][2], facel[k][0][2])
            cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][0][2], facel[5][1][2], facel[6][1][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][1][2], facel[5][2][2], facel[6][2][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][2][2], facel[5][3][2], facel[6][3][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [facel[5][3][2], facel[5][0][2], facel[6][0][2]])
            k = 6
            line31(vert, facel[0][0][2], facel[k][0][2])
            line31(vert, facel[k][0][2], facel[5][0][2])
            line31(vert, facel[5][0][2], facel[k][1][2])
            line31(vert, facel[k][1][2], facel[0][0][2])
            j = 1
            line31(vert, facel[0][j][2], facel[k][j][2])
            line31(vert, facel[k][j][2], facel[5][j][2])
            line31(vert, facel[5][j][2], facel[k][j + 1][2])
            line31(vert, facel[k][j + 1][2], facel[0][j][2])

            j = 2
            line31(vert, facel[0][j][2], facel[k][j][2])
            line31(vert, facel[k][j][2], facel[5][j][2])
            line31(vert, facel[5][j][2], facel[k][j + 1][2])
            line31(vert, facel[k][j + 1][2], facel[0][j][2])

            j = 3
            line31(vert, facel[0][j][2], facel[k][j][2])
            line31(vert, facel[k][j][2], facel[5][j][2])
            line31(vert, facel[5][j][2], facel[k][0][2])
            line31(vert, facel[k][0][2], facel[0][j][2])



            line32(vert, facel[0][0][0], facel[0][0][2])
            line32(vert, facel[0][0][0], facel[6][0][2])
            line32(vert, facel[0][0][0], facel[0][3][2])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][0][0]], facel[6][0][2], facel[0][3][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][0][0]], facel[6][0][2], facel[0][0][2]])
            line32(vert, facel[0][1][0], facel[0][0][2])
            line32(vert, facel[0][1][0], facel[6][1][2])
            line32(vert, facel[0][1][0], facel[0][1][2])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][1][0]], facel[6][1][2], facel[0][0][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][1][0]], facel[6][1][2], facel[0][1][2]])
            line32(vert, facel[0][2][0], facel[0][1][2])
            line32(vert, facel[0][2][0], facel[6][2][2])
            line32(vert, facel[0][2][0], facel[0][2][2])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][2][0]], facel[6][2][2], facel[0][2][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][2][0]], facel[6][2][2], facel[0][1][2]])
            line32(vert, facel[0][3][0], facel[0][2][2])
            line32(vert, facel[0][3][0], facel[6][3][2])
            line32(vert, facel[0][3][0], facel[0][3][2])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][3][0]], facel[6][3][2], facel[0][2][2]])
            cut3D(imgs[2], x, y, 3, 100, d, an, [vert[facel[0][3][0]], facel[6][3][2], facel[0][3][2]])
            // const wh = { w: img[org].width, h: img[org].height };
            //const t = rectToSquare(wh, x, y, d)
            var geti = img[org].get(t.tl.x, t.tl.y, t.w, t.w)

            k = 5
            cut3D(imgs[0], x, y, 1, 100, d, an, [facel[k][0][2], facel[k][1][2], facel[k][3][2], facel[k][2][2]])
            k = 6
            cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][0][2], facel[k][1][2], facel[k][0][2], facel[0][0][2]])
            cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][1][2], facel[k][2][2], facel[k][1][2], facel[0][1][2]])
            cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][2][2], facel[k][3][2], facel[k][2][2], facel[0][2][2]])
            cut3D(imgs[0], x, y, 1, 100, d, an, [facel[5][3][2], facel[k][0][2], facel[k][3][2], facel[0][3][2]])
            var gete = shape2.get(0, 0, l, l)
            shape2.push()
            shape2.translate(0, 0, -l)
            shape2.image(gete, 0, 0, l * 1, l * 1)


            //}
            //if(i<4) {
            /* 
            shape2.beginShape()
            shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
            edgi=vert[i].face
            shape2.vertex(vert[edgi].x, vert[edgi].y, vert[edgi].z);
            shape2.endShape();
            shape2.fill(255)
            shape2.noStroke()
            shape2.push()
            shape2.translate(vert[i].mid.x,vert[i].mid.y,vert[i].mid.z)
            shape2.ellipse(0,0,40,40)
            shape2.pop()
            //if(i>3){
               shape2.push()
                shape2.stroke(255)
                shape2.noFill()
                shape2.translate(vert[i].midef.x,vert[i].midef.y,vert[i].midef.z)
                 if(i>4){

                    shape2.ellipse(0,0,40,40)
                }
                if(i==4|| i==6){
                    shape2.rotateX(HALF_PI)
                    shape2.ellipse(0,0,280,280)
                }
                if(i==5|| i==7){
                    shape2.rotateY(HALF_PI)
                    shape2.ellipse(0,0,280,280)
                }
               
                
                shape2.pop()
                */

            shape2.pop()
        });

        shapes.set(5.3, (n, d, tr, an, x, y) => {
            var title = "Sun and floor";
            var l = min(width, height);
            shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);
            var gete = shape2.get(0, 0, l, l)
            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            const vert = getPlaneMidSide(l, l * 10, l * 3.48)
            shape2.push()

            shape2.translate(-l * 2, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.pop()
        });

        shapes.set(5.31, (n, d, tr, an, x, y, gete = img[org]) => {
            var title = "Sun and floor";
            var l = min(width, height);
            //shapes.get(4.51).apply(null, [n, d, { scl: l, rtt: 0, trx: 0, try: 0 }, an, x, y]);

            shape2.clear()
            shape2 = createGraphics(l, l, WEBGL);
            const vert = getPlaneMidSide(l, l * 10, l * 2 * an)
            shape2.push()

            shape2.translate(-l * 2, l / 2, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.translate(l * 2, 0, 0)
            cut3D(gete, x, y, 1, 100, d, an, vert)
            shape2.pop()
        });
        shapes.set(5.4, (n, d, tr, an, x, y, gete = img[org]) => {
            var title = 'Star photo and lines'
            var l = min(width, height);
            let vert = getStarN(n, l * 0.5, -4, -4)
            shape2 = createGraphics(l, l, WEBGL);
            let sh = img[org]
            let wh = { w: img[org].width, h: img[org].height }
            let imgs = []
            var dd = d * 0.5
            var xd = x + d * 0.5 * cos(0)
            var yd = x + d * 0.5 * cos(0)
            let t = rectToSquare(wh, xd, yd, dd)
            for (var j = 0; j < vert.length; j++) {
                imgs[j] = sh.get(t.tl.x, t.tl.y, t.w, t.w)
                xd = x + d * 0.5 * cos(an * (j + 1))
                yd = y + d * 0.5 * sin(an * (j + 1))
                t = rectToSquare(wh, xd, yd, dd)
            }
            let coln = img[org].get(x, y)
            shape2.push()
            shape2.translate(0, 0, -l * 1)
            shape2.rotate(an)
            var wei = l * 4 / n / 6
            var colx = 1; //x+d*cos(an*i)
            var coly = 1; //y+d*sin(an*i)
            for (let i = 0; i < vert.length; i++) {
                coln = imgs[i].get(colx, coly)
                shape2.push()
                shape2.translate(vert[i].x, vert[i].y, vert[i].z + wei)
                shape2.texture(imgs[i])
                shape2.ellipse(0, 0, wei * 2.5, wei * 2.5)
                shape2.pop()
                if (i < vert.length - 1) {
                    shape2.strokeWeight(wei)
                    shape2.stroke(coln)
                    shape2.beginShape();
                    shape2.vertex(vert[i].x, vert[i].y, vert[i].z);
                    shape2.vertex(vert[i + 1].x, vert[i + 1].y, vert[i + 1].z);
                    shape2.endShape();

                }
                if (i % 3 == 0 && i > 2) {}
                shape2.noStroke()
            }
            shape2.strokeWeight(wei)
            shape2.stroke(coln)
            shape2.beginShape();
            shape2.vertex(vert[vert.length - 1].x, vert[vert.length - 1].y, vert[vert.length - 1].z);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z);
            shape2.endShape();
            shape2.pop()

        });
    }


    function cutTriangle(org, x, y, n, r, d, an = 1, extra = {}) {
        if (n == 1) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 2) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0 + r * sin(HALF_PI / 3), 0, x, y + d * sin(HALF_PI / 3));
            shape2.vertex(
                0 + r * cos(HALF_PI / 3),
                0 + r * sin(HALF_PI / 3),
                0,
                x + d * cos(HALF_PI / 3),
                y + d * sin(HALF_PI / 3)
            );
            shape2.vertex(0, 0, 0, x, y);
            shape2.endShape(CLOSE);
        }

        if (n == 3) {
            //Cut arrow 1/3 from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);
            shape2.vertex(
                0 + r * cos(HALF_PI / 3),
                0 + r * sin(HALF_PI / 3),
                0,
                x + d * cos(HALF_PI / 3),
                y + d * sin(HALF_PI / 3)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }

        if (n == 4) {
            //Cut arrow aperture from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 5) {
            //Cut isosceles aperture from regular triangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, r * sin(an), 0, x, y + d * sin(an));

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(-HALF_PI),
                0 + r * sin(-HALF_PI),
                0,
                x + d * cos(-HALF_PI),
                y + d * sin(-HALF_PI)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 6) {
            //Cut section from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * cos(an),
                0 + r * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * cos(0),
                0 + r * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 6.1) {
            const r2 = 1.42; //2root aprox
            //Cut section from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r * r2 * cos(an),
                0 + r * r2 * sin(an),
                0,
                x + d * cos(an),
                y + d * sin(an)
            );
            shape2.vertex(
                0 + r * r2 * cos(0),
                0 + r * r2 * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 7) {
            //Cut semi section deltoid (diamond) from circle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(0, 0, 0, x, y);

            shape2.vertex(
                0 + r / 2 * cos(an),
                0 + r / 2 * sin(an),
                0,
                x + d / 2 * cos(an),
                y + d / 2 * sin(an)
            );
            shape2.vertex(
                0 + r * cos(0),
                0 + r * sin(0),
                0,
                x + d * cos(0),
                y + d * sin(0)
            );
            shape2.endShape(CLOSE);
        }
        if (n == 8) {
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(r, 0, 0, x + d, y);
            shape2.endShape(CLOSE);
        }
        if (n == 9) {
            //Cut semi section quart squrae centered
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(
                -r / 2,
                r / 2,
                0,
                x - d / 2,
                y + d / 2
            );
            shape2.vertex(
                r / 2,
                r / 2,
                0,
                x + d / 2,
                y + d / 2
            );
            shape2.vertex(
                r / 2,
                -r / 2,
                0,
                x + d / 2,
                y - d / 2
            );
            shape2.endShape(CLOSE);
        }
        if (n == 10) {
            //Cut semi section deltoid from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            var r1 = r / 3
            var r2 = r / 2
            var r3 = r

            var d1 = d / 3
            var d2 = d / 2
            var d3 = d

            const p = []
            p[0] = { x: r1, y: 0 }
            p[1] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[2] = { x: r3, y: 0 }
            const s = []
            s[0] = { x: x + d1, y: y }
            s[1] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[2] = { x: x + d3, y: y }

            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.endShape(CLOSE);
        }

    }



    function getSemisides(sqr, w, h) {
        // Calcula la proporción entre el lado del cuadrado y el lado mayor del rectángulo
        const propor = sqr / Math.max(w, h);

        // Calcula las nuevas dimensiones del rectángulo
        const ww = w * propor;
        const hh = h * propor;

        // Devuelve la mitad de las nuevas dimensiones y la proporción en un array
        return [ww, hh, propor];
    }


    function calcRectSides(a, d) {
        // Calcula la longitud del lado perpendicular al apoyado
        var w = d * Math.cos(a);

        // Calcula la longitud del lado apoyado
        var h = d * Math.sin(a);

        // Devuelve los semilados del rectángulo
        return { w: w, h: h };
    }

    function cutSquare(org, x, y, n, r, d, an = 1, extra = {}) {
        if (n == 0) {
            const wh = { w: img[org].width, h: img[org].height };
            const t = rectToSquare(wh, x, y, d)
            //const t= rectToSquare(wh,0,0,wh.w)
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-r, -r, 0, t.tl.x, t.tl.y);
            shape2.vertex(-r, r, 0, t.tl.x, t.tl.y + t.w);
            shape2.vertex(r, -r, 0, t.br.x, t.br.y - t.w);
            shape2.vertex(r, r, 0, t.br.x, t.br.y);
            shape2.endShape(CLOSE);
        }
        if (n == 0.1) {
            const wh = { w: img[org].width, h: img[org].height };
            var sd = calcRectSides(an, d)
            const t = { tl: { x: x - sd.w, y: y - sd.h }, br: { x: x + sd.w, y: y + sd.h }, w: sd.w * 2, h: sd.h * 2 }
            var u = getSemisides(r, sd.w, sd.h)
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-u[0], -u[1], 0, t.tl.x, t.tl.y);
            shape2.vertex(-u[0], u[1], 0, t.tl.x, t.tl.y + t.h);
            shape2.vertex(u[0], -u[1], 0, t.br.x, t.br.y - t.h);
            shape2.vertex(u[0], u[1], 0, t.br.x, t.br.y);
            shape2.endShape(CLOSE);
        }
        if (n == 0.4) {
            const wh = { w: img[org].width, h: img[org].height };
            const t = rectToSquare(wh, x, y, d)
            let r1 = r
            let r2 = r * 2
            let r4 = r * 4
            let pa = createGraphics(r2, r2, WEBGL);
            let geri = img[org].get(x, y, d, d)
            pa.push();
            pa.image(geri, 0, 0, r, r);
            /* pa.scale(-1, 1);
             pa.translate(-r2, 0);
             pa.image(geri, 0, 0);
             pa.scale(1, -1);
             pa.translate(0, -r2);
             pa.image(geri, 0, 0);
             pa.scale(-1, 1);
             pa.translate(-r2, 0);
             pa.image(geri, 0, 0);
             */
            pa.pop();
            shape2.image(pa, 0, 0)
            //let im4=image(pa,0,0)
            //shape2 = createGraphics(r2,r2);
            //let gera=pa.get(0,0,r2*1,r2*1)
            for (var a = 0; a < 4; a++) {
                ////shape2.image(gera,a*r,0)
            }
            //shape2.image(gera,0,0)
            // shape2.textureWrap(MIRROR);
            /*
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(gera);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(-r, -r, 0, 0,  0);
            shape2.vertex(-r, r, 0, 0, r2);
            shape2.vertex(r, -r, 0, r2,  0 );
            shape2.vertex(r, r, 0, r2,  r2);
            shape2.endShape(CLOSE);
            image(shape2,0,0)
            */
        }
        if (n == 1) {
            //cut half square
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 4;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.vertex(r, -r, 0, x + d, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 2) {
            // cut half rectangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 2;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(an, r, 0, x + an, y + d);
            shape2.vertex(0, -r, 0, x, y - d);
            shape2.vertex(an, -r, 0, x + an, y - d);
            shape2.endShape(CLOSE);
        }
        if (n == 3) {
            // cut quarter rectangle
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            d = d / 2;
            shape2.vertex(0, r, 0, x, y + d);
            shape2.vertex(r, r, 0, x + d, y + d);
            shape2.vertex(0, 0, 0, x, y);
            shape2.vertex(r, 0, 0, x + d, y);
            shape2.endShape(CLOSE);
        }

        if (n == 4) {
            //Cut leaf from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            //var r=200
            var r1 = r / 4
            var rr1 = r / 2.5
            var r2 = r / 2
            var rr2 = (r / 3) * 2
            var r3 = r

            var d1 = d / 4
            var dd1 = d / 2.5
            var d2 = d / 2
            var dd2 = (d * 3) * 2
            var d3 = d

            const p = []
            p[0] = { x: r1 * cos(an), y: r1 * sin(an) }
            p[1] = { x: rr1, y: 0 }
            p[2] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[3] = { x: rr2, y: 0 }
            p[4] = { x: r3 * cos(an), y: r3 * sin(an) }
            const s = []
            s[0] = { x: x + d1 * cos(an), y: y + d1 * sin(an) }
            s[1] = { x: x + dd2, y: y }
            s[2] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[3] = { x: x + dd2, y: y }
            s[4] = { x: x + d3 * cos(an), y: y + d3 * sin(an) }
            shape2.vertex(
                p[4].x,
                p[4].y,
                0,
                s[4].x,
                s[4].y
            );
            shape2.vertex(
                p[3].x,
                p[3].y,
                0,
                s[3].x,
                s[3].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.endShape(CLOSE);
        }
        if (n == 5) {
            //Cut leaf from circle scaled
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(img[org]);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            //var r=200
            var r1 = r * 0.5
            var rr1 = r * 0.5
            var r2 = r * 0.75
            var rr2 = r
            var r3 = r

            var d1 = d * 0.5
            var dd1 = d * 0.5
            var d2 = d * 0.75
            var dd2 = d
            var d3 = d

            const p = []
            p[0] = { x: r1 * cos(an), y: r1 * sin(an) }
            p[1] = { x: rr1, y: 0 }
            p[2] = { x: r2 * cos(an), y: r2 * sin(an) }
            p[3] = { x: rr2, y: 0 }
            p[4] = { x: r3 * cos(an), y: r3 * sin(an) }
            const s = []
            s[0] = { x: x + d1 * cos(an), y: y + d1 * sin(an) }
            s[1] = { x: x + dd2, y: y }
            s[2] = { x: x + d2 * cos(an), y: y + d2 * sin(an) }
            s[3] = { x: x + dd2, y: y }
            s[4] = { x: x + d3 * cos(an), y: y + d3 * sin(an) }
            shape2.vertex(
                p[4].x,
                p[4].y,
                0,
                s[4].x,
                s[4].y
            );
            shape2.vertex(
                p[3].x,
                p[3].y,
                0,
                s[3].x,
                s[3].y
            );
            shape2.vertex(
                p[2].x,
                p[2].y,
                0,
                s[2].x,
                s[2].y
            );
            shape2.vertex(
                p[1].x,
                p[1].y,
                0,
                s[1].x,
                s[1].y
            );
            shape2.vertex(
                p[0].x,
                p[0].y,
                0,
                s[0].x,
                s[0].y
            );
            shape2.endShape(CLOSE);
        }

    }
    ///////////////////////////////////
    
function interlines(x1, y1, x2, y2, x3, y3, x4, y4) {
    //1.108
    //if (x1 === x2 || x3 === x4) {return "No";}
    var m1 = (y2 - y1) / (x2 - x1);
    var m2 = (y4 - y3) / (x4 - x3);
    if (m1 === m2) {
        return "No";
    }
    var xInt = (m1 * x1 - m2 * x3 + y3 - y1) / (m1 - m2);
    var yInt = m1 * (xInt - x1) + y1;
    if (isNaN(xInt) || isNaN(yInt)) {return "No"; }
    return {x:xInt, y:yInt};
}

    function compareZ(a, b) {
        return b.z - a.z;
    }

    function getTetraVert(sideLength) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [0.25, 0.25, 0.25],
            [-0.25, 0.5, 0.25],
            [0.25, -0.25, 0.25],
            [-0.25, -0.25, -0.25],
        ];
        const scalingFactor = sideLength / Math.sqrt(2);
        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {
                vert[i][j] *= scalingFactor;
            }
        }
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

    function getPlaneMidSide(sside, prof = 1, app = 0) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [-sside, 0, 0],
            [sside, 0, 0],
            [-sside, -app, -prof],
            [sside, -app, -prof],
        ];
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

    function getBoxVert(scalingFactor, prof) {
        const type = 'box_centered'
        const center = [0, 0, 0];
        const vert = [
            [-0.5, 0.5, 0.5, [1, 4], 5], // Vér 0
            [0.5, 0.5, 0.5, [2, 5], 6], // Vert 1
            [0.5, -0.5, 0.5, [3, 6], 7], // Vert 2
            [-0.5, -0.5, 0.5, [0, 7], 4], // Vert 3
            [-0.5, 0.5, -0.5, [5], 1], // Vert 4
            [0.5, 0.5, -0.5, [6], 2], // Vert 5
            [0.5, -0.5, -0.5, [7], 3], // Vert 6
            [-0.5, -0.5, -0.5, [4], 0], // Vert 7
        ];
        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {
                vert[i][j] *= scalingFactor;
                if (i > 3 && j == 2) {
                    vert[i][j] -= prof
                }

            }
        }
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
                edge: p[3],
                face: p[4],
            };

        });
    }

    function ivertex(scaling, p) {
        let v = [
            [-0.5, 0.5, 0.5], // Vértice 0
            [0.5, 0.5, 0.5], // Vértice 1
            [0.5, -0.5, 0.5], // Vértice 2
            [-0.5, -0.5, 0.5], // Vértice 3
            [-0.5, 0.5, -0.5], // Vértice 4
            [0.5, 0.5, -0.5], // Vértice 5
            [0.5, -0.5, -0.5], // Vértice 6
            [-0.5, -0.5, -0.5], // Vértice 7
        ];

        for (let i = 0; i < v.length; i++) {
            for (let j = 0; j < 3; j++) {
                v[i][j] *= scaling;

                if (i > 3 && j == 2) {
                    v[i][j] -= p;
                }
            }
        }
        return v;
    }

    function evertex(sx, sy, sz) {
        let v = [
            [0, 0, 0], // Vértice 0
            [1, 0, 0], // Vértice 1
            [1, -1, 0], // Vértice 2
            [0, -1, 0], // Vértice 3
            [0, 0, -1], // Vértice 4
            [1, 0, -1], // Vértice 5
            [1, -1, -1], // Vértice 6
            [0, -1, -1], // Vértice 7
        ];
        for (let i = 0; i < v.length; i++) {
            v[i][0] *= sx;
            v[i][1] *= sy;
            v[i][2] *= sz;
        }
        return v;
    }
    const facel = [
        // Cara delantera 0
        [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 0],
        ],

        //cara lateral 1
        [
            [0, 1],
            [1, 5],
            [5, 4],
            [4, 0],
        ],
        //cara lateral 2
        [
            [1, 2],
            [2, 6],
            [6, 5],
            [5, 1],
        ],
        //cara lateral 3
        [
            [2, 3],
            [3, 7],
            [7, 6],
            [6, 2],
        ],
        //cara lateral 4
        [
            [3, 0],
            [0, 4],
            [4, 7],
            [7, 3],
        ],
        // Caras posterior 5
        [
            [4, 5],
            [5, 6],
            [6, 7],
            [7, 4],
        ],
        // aristas laterales
        [
            [0, 4],
            [1, 5],
            [2, 6],
            [3, 7],
        ],
    ];


    function mpoint(vert, f) {

        var v1 = f[0];
        var v2 = f[1];
        var v5 = createVector(vert[v1][0], vert[v1][1], vert[v1][2]);
        var v6 = createVector(vert[v2][0], vert[v2][1], vert[v2][2]);
        return p5.Vector.lerp(v5, v6, 0.5);

    }

    function mpoint2(vert, a, e) {
        var v5 = createVector(vert[a].x, vert[a].y, vert[a].z);
        var v6 = createVector(vert[e].x, vert[e].y, vert[e].z);
        var a = p5.Vector.lerp(v5, v6, 0.5);
        return { x: a.x, y: a.y, z: a.z }
    }

    function line3(vert, a, e) {
        shape2.beginShape();
        shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
        shape2.vertex(vert[e].x, vert[e].y, vert[e].z);
        shape2.endShape();
    }

    function line31(vert, a, e) {
        shape2.beginShape();
        shape2.vertex(a.x, a.y, a.z);
        shape2.vertex(e.x, e.y, e.z);
        shape2.endShape();
    }

    function line32(vert, a, e) {
        shape2.beginShape();
        shape2.vertex(vert[a].x, vert[a].y, vert[a].z);
        shape2.vertex(e.x, e.y, e.z);
        shape2.endShape();
    }

    function getBoxData(scalingFactor, prof) {
        /*
              7 -------- 6
             /|         /|
            3 -------- 2 |
            | |        | |
            | |   i    | |
            | 4 -------| 5
            |/         |/
            0e ------- 1
          */

        let vert = ivertex(scalingFactor, prof)
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };

        });

    }

    function getHelixBoxVert(scalingFactor, prof) {
        const type = 'tetrahedron_regular_centered'
        const center = [0, 0, 0];
        const vert = [
            [-0.5, 0.5, 0.5], // Vértice 1
            [0.5, 0.5, 0.5], // Vértice 2
            [0.5, -0.5, 0.5], // Vértice 3
            [-0.5, -0.5, 0.5], // Vértice 4
            [-0.5, 0.5, -0.5], // Vértice 5
            [0.5, 0.5, -0.5], // Vértice 6
            [0.5, -0.5, -0.5], // Vértice 7
            [-0.5, -0.5, -0.5], // Vértice 8
        ];

        for (let i = 0; i < vert.length; i++) {
            for (let j = 0; j < 3; j++) {

                vert[i][j] *= scalingFactor;
                if (i > 3 && j == 2) {
                    vert[i][j] -= prof
                }
            }
            if (i == vert.length - 1) {
                vert[i][2] -= prof
            }
        }
        return vert.map((p) => {
            return {
                x: p[0],
                y: p[1],
                z: p[2],
            };
        });
    }

    function getStar(scale, z1) {
        const verts = [];
        let radius;
        let z = 1
        for (let i = 0; i < 10; i++) {
            //radius = i % 2 === 0 ? 1 : 0.5;
            if (i % 2 === 0) {
                radius = 1;
                z = z1
            } else {
                radius = 0.5;
                z = z1 * scale
            }
            const angle = i * Math.PI / 5;
            const x = radius * Math.cos(angle) * scale;
            const y = radius * Math.sin(angle) * scale;
            verts.push({ x, y, z });
        }
        return verts;
    }

    function getStarN(numPoints, scale, z1, z2) {
        const verts = [];
        let radius;
        let z = 1
        for (let i = 0; i < numPoints; i++) {
            if (i % 2 === 0) {
                radius = 1;
                z = z1
            } else {
                radius = 0.5;
                z = z2
            }
            //const angle = i * Math.PI / numPoints;
            const angle = (2 * Math.PI * i) / numPoints;
            const x = radius * Math.cos(angle) * scale;
            const y = radius * Math.sin(angle) * scale;
            verts.push({ x, y, z });
        }
        return verts;
    }

    /////////////////////    
    function cut3D(ime, x, y, n, r, d, an = 1, vert = []) {
        if (n == 1) {
            //plane
            var side = d
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(ime);
            var w = ime.width
            var h = ime.height
            //shape2.fill(0, 255, 0);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z, 0, 0);
            shape2.vertex(vert[1].x, vert[1].y, vert[1].z, w, 0);
            shape2.vertex(vert[2].x, vert[2].y, vert[2].z, 0, h);
            shape2.vertex(vert[3].x, vert[3].y, vert[3].z, w, h);
            shape2.endShape();
        }
        if (n == 2) {
            //Tetrahedrom faces
            var side = d
            //tetrahedrom
            shape2.fill(0, 255, 0);
            shape2.beginShape(TRIANGLES);
            shape2.vertex(side, side, side);
            shape2.vertex(-side, -side, side);
            shape2.vertex(side, -side, -side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(0, 0, 255);
            shape2.vertex(-side, -side, side);
            shape2.vertex(side, -side, -side);
            shape2.vertex(-side, side, -side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(255, 0, 0);
            shape2.vertex(side, side, side);
            shape2.vertex(-side, side, -side);
            shape2.vertex(-side, -side, side);
            shape2.endShape();

            shape2.beginShape(TRIANGLES);
            shape2.fill(255, 255, 0);
            shape2.vertex(side, side, side);
            shape2.vertex(side, -side, -side);
            shape2.vertex(-side, side, -side);
            shape2.endShape();
        }

        if (n == 3) {
            //triangle
            var side = d
            shape2.beginShape(TRIANGLE_STRIP);
            shape2.texture(ime);
            var w = ime.width
            var h = ime.height
            //shape2.fill(0, 255, 0);
            shape2.noStroke();
            shape2.imageMode(CENTER);
            shape2.vertex(vert[0].x, vert[0].y, vert[0].z, 0, 0);
            shape2.vertex(vert[1].x, vert[1].y, vert[1].z, w, h / 2);
            shape2.vertex(vert[2].x, vert[2].y, vert[2].z, 0, h);
            shape2.endShape();
        }
    }

    function bez(t, a, b, c, d) {
        return {
            x: ((1 - t) ** 3) * a.x + 3 * (1 - t) ** 2 * t * b.x + 3 * (1 - t) * t ** 2 * c.x + t ** 3 * d.x,
            y: (1 - t) ** 3 * a.y + 3 * (1 - t) ** 2 * t * b.y + 3 * (1 - t) * t ** 2 * c.y + t ** 3 * d.y
        }
    }
    //////////////////////
    class Flower {
        //1.8
        constructor(cx, cy, x, y, d, r, nn, petal) {
            this.n = 6;
            this.r = r;
            this.nn = nn;
            this.cx = cx;
            this.cy = cy;
            this.aco = this.loadColor(x, y, d);
            this.petal = petal;
        }
        init() {
            shape2.noStroke()
            var r = this.r,
                nn = this.nn,
                petal = this.petal
            var colorLayer = 0
            this.polen(this.cx, this.cy, this.n, r, nn, petal, colorLayer);
            var mod = r * (sqrt(3) / 2);
            var mad = PI / 3;
            var imad = PI / 6;
            var x, y;
            colorLayer = 1
            for (var a = 0; a < 6; a++) {
                x = r * 2 * cos(imad + mad * a);
                y = r * 2 * sin(imad + mad * a);
                var cola = a % 2
                this.polen(x, y, this.n, r, nn, petal, cola);
            }

            var x0, y0, x1, y1, x2, y2;
            colorLayer = 2
            for (a = 0; a < 6; a++) {
                x1 = r * cos(a * mad - imad);
                y1 = r * sin(a * mad - imad);
                x2 = mod * 2 * cos(a * mad);
                y2 = mod * 2 * sin(a * mad);
                x0 = r * cos(a * mad + imad);
                y0 = r * sin(a * mad + imad);
                this.trilen(x0, y0, x1, y1, x2, y2, nn, petal, colorLayer);
            }
            colorLayer = 3
            for (a = 0; a < 8; a++) {
                x0 = mod * 2 * cos(a * mad);
                y0 = mod * 2 * sin(a * mad);
                x1 = x0 + r * cos(a * mad - imad);
                y1 = y0 + r * sin(a * mad - imad);
                x2 = x0 + r * cos(a * mad + imad);
                y2 = y0 + r * sin(a * mad + imad);
                this.trilen(x0, y0, x1, y1, x2, y2, nn, petal, colorLayer);
            }
        }

        polen(x0, y0, n, r, vert = 2, mode = false, colorLayer = 0) {
            var xi = x0;
            var yi = y0;
            var verti = vert;
            var mod = TWO_PI / n;
            var an = -HALF_PI;
            var x1, y1, x2, y2;

            for (var v = 0; v < n; v++) {
                x1 = x0 + r * cos(an);
                y1 = y0 + r * sin(an);
                an += mod;
                x2 = x0 + r * cos(an);
                y2 = y0 + r * sin(an);
                var cola = v % 3
                this.trilen(x0, y0, x1, y1, x2, y2, verti, mode, colorLayer);
            }
        }
        trilen(x0, y0, x1, y1, x2, y2, nn, extra = false, colorLayer = 0) {
            var bo1 = [];
            var bo2 = [];
            var bo3 = [];
            var bo = [];
            shape2.fill(this.aco[0][0]);
            //shape2.texture(img[org])
            shape2.beginShape();
            shape2.vertex(x0, y0);
            shape2.vertex(x1, y1);
            shape2.vertex(x2, y2);
            shape2.endShape();
            shape2.fill(this.aco[colorLayer][1]);
            if (extra) {
                this.equilen(x0, y0, x1, y1, 1, nn);
            }
            shape2.fill(this.aco[colorLayer][2]);
            bo1 = this.equilen(x0, y0, x1, y1, -1, nn);
            if (extra) {
                this.equilen(x1, y1, x2, y2, 1, nn);
            }
            shape2.fill(this.aco[colorLayer][1]);
            bo2 = this.equilen(x1, y1, x2, y2, -1, nn);
            shape2.fill(this.aco[colorLayer][1]);
            if (extra) {
                shape2.fill(this.aco[colorLayer][2]);
                this.equilen(x2, y2, x0, y0, 1, nn);
            }
            shape2.fill(this.aco[colorLayer][1]);
            bo3 = this.equilen(x2, y2, x0, y0, -1, nn);
            bo = bo1.concat(bo2, bo3);
            if (nn < 5) {
                shape2.fill(this.aco[colorLayer][3]);
                shape2.beginShape();
                shape2.vertex(bo1[bo1.length - 1].x, bo1[bo1.length - 1].y);
                shape2.vertex(bo1[bo1.length - 2].x, bo1[bo1.length - 2].y);
                shape2.vertex(bo3[1].x, bo3[1].y);
                shape2.endShape(CLOSE);
                shape2.fill(this.aco[colorLayer][4]);
                shape2.beginShape();
                shape2.vertex(bo2[bo2.length - 1].x, bo2[bo2.length - 1].y);
                shape2.vertex(bo2[bo1.length - 2].x, bo2[bo2.length - 2].y);
                shape2.vertex(bo1[1].x, bo1[1].y);
                shape2.endShape(CLOSE);
                shape2.fill(this.aco[colorLayer][4]);
                shape2.beginShape();
                shape2.vertex(bo3[bo3.length - 1].x, bo3[bo3.length - 1].y);
                shape2.vertex(bo3[bo3.length - 2].x, bo3[bo3.length - 2].y);
                shape2.vertex(bo2[1].x, bo2[1].y);
                shape2.endShape(CLOSE);
            }
        }
        equilen(x0, y0, x1, y1, emi = 1, n = 12) {
            let ca = 0;
            let ce = 0;
            let x2 = 0;
            let y2 = 0;
            var an = atan2(y1 - y0, x1 - x0);
            var r = dist(x0, y0, x1, y1);
            ca = an + (PI - PI / 3);
            ce = an + (PI + PI / 3);
            let se = 0;
            if (emi == 1) {
                x2 = x1 + r * cos(ca);
                y2 = y1 + r * sin(ca);
                se = ce;
            }
            if (emi == -1) {
                x2 = x1 + r * cos(ce);
                y2 = y1 + r * sin(ce);
                se = ca;
            }
            var ani = atan2(y1 - y2, x1 - x2);
            var mod = PI / 3 / n;
            var can = ani;
            var m = [];

            shape2.beginShape();
            var x, y;
            for (var a = 0; a < n + 1; a++) {
                x = x2 + r * cos(can);
                y = y2 + r * sin(can);
                shape2.vertex(x, y);
                //if(a>0 && a<n){
                m.push({ x: x, y: y });
                //}
                if (emi == 1) {
                    can -= mod;
                }
                if (emi == -1) {
                    can += mod;
                }
            }
            shape2.endShape(CLOSE);
            return m;
        }
        flowbox(face, pos, ny, r, coa) {
            //0.102
            var ain = 0;
            var rr = r;
            if (ny == 0) {
                ain = -PI / 6;
                rr = 0;
            }
            if (ny == 1) {
                ain = PI + PI / 6;
                rr = r * 2;
            }
            if (ny == 2) {
                ain = -PI / 2;
                rr = r * 2;
            }
            if (ny == 3) {
                ain = -PI / 6;
                rr = r * 2;
            }
            if (ny == 4) {
                ain = PI / 6;
                rr = r * 2;
            }
            if (ny == 5) {
                ain = PI / 2;
                rr = r * 2;
            }
            if (ny == 6) {
                ain = PI - PI / 6;
                rr = r * 2;
            }

            var x0 = pos.x + rr * cos(ain);
            var y0 = pos.y + rr * sin(ain);
            var x1, y1, x2, y2, x3, y3;
            var mod = PI / 3;
            var an = PI + PI / 6;
            var r2 = r;
            if (face == 1) {
                an = PI + PI / 6;
                //var co1 = [...this.aco[0][1]];
                //co1[3] = 140;
               shape2.fill(coa[1]);
            }
            if (face == 2) {
                an = -PI / 6;
                //shape2.fill(this.aco[0][2]);
                shape2.fill(coa[2]);
            }
            if (face == 3) {
                an = HALF_PI;
                //shape2.fill(this.aco[0][3]);
                shape2.fill(coa[3]);
            }
            if (face == 4) {
                an = HALF_PI / 3;
                shape2.fill(coa[4]);
            }
            if (face == 5) {
                an = PI - PI / 6;
                shape2.fill(coa[5]);
            }

            if (face == 6) {
                an = -PI / 2;
                shape2.fill(coa[6]);
            }
            if (face == 7) {
                an = -PI / 2;
                mod = PI / 6;
                shape2.fill(coa[7]);
                r2 = r * 2 * (sqrt(3) / 2);
            }
            if (face == 8) {
                an = -PI / 6;
                mod = PI / 6;
                shape2.fill(coa[8]);
                r2 = r * 2 * (sqrt(3) / 2);
            }
            if (face == 9) {
                an = PI / 6;
                mod = PI / 6;
                shape2.fill(coa[9]);
                r2 = r * 2 * (sqrt(3) / 2);
            }
            if (face == 10) {
                an = PI / 2;
                mod = PI / 6;
                shape2.fill(coa[10]);
                r2 = r * 2 * (sqrt(3) / 2);
            }
            if (face == 11) {
                an = PI - PI / 6;
                mod = PI / 6;
                shape2.fill(coa[11]);
                r2 = r * 2 * (sqrt(3) / 2);
            }

            if (face == 12) {
                an = PI + PI / 6;
                mod = PI / 6;
                shape2.fill(coa[12]);
                r2 = r * 2 * (sqrt(3) / 2);
            }

            x1 = x0 + r * cos(an);
            y1 = y0 + r * sin(an);
            an += mod;
            x2 = x0 + r2 * cos(an);
            y2 = y0 + r2 * sin(an);
            an += mod;
            x3 = x0 + r * cos(an);
            y3 = y0 + r * sin(an);

            shape2.beginShape();
            shape2.vertex(x0, y0);
            shape2.vertex(x1, y1);
            shape2.vertex(x2, y2);
            shape2.vertex(x3, y3);
            shape2.endShape(CLOSE);

        }
        loadColor(x, y, d) {
            var aco = [
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            ];
            if (floor(d) % 2 == 0) {
                aco[0][0] = [0, 0, 0, 0];
            }
            var col = [];
            var mod = floor(d / 6)
            for (var j = 0; j < 13; j++) {
                col = img[org].get(x + mod * j, y)
                aco[0].push(col);
                col = img[org].get(x, y + mod * j)
                aco[1].push(col);
                col = img[org].get(x + mod * 3 + j, y + j)
                aco[2].push(col);
                col = img[org].get(x + j, y + mod * 3 + j)
                aco[3].push(col);
                col = img[org].get(x, y + d / 2 + j)
                aco[4].push(col);
                col = img[org].get(x + d / 2 + j, y + d / 2 + j)
                aco[5].push(col)
                col = img[org].get(x + mod * 1, y + mod * 1)
                aco[6].push(col)
                col = img[org].get(x + mod * 2, y + mod * 1)
                aco[7].push(col)
                col = img[org].get(x + mod * 3, y + mod * 2)
                aco[8].push(col)
                col = img[org].get(x + mod * 4, y + mod * 2)
                aco[9].push(col)
                col = img[org].get(x + mod * 5, y + mod * 3)
                aco[10].push(col)
                col = img[org].get(x + mod * 6, y + mod * 4)
                aco[11].push(col)
                col = img[org].get(x + mod * 1, y + mod * 4)
                aco[12].push(col)

            }
            return aco;
        }
    }

class Circone {
    //0.108 use
  constructor(x1=0,y1=-200, x2=0,y2=200,iangle=PI/2) {
    this.iangle = iangle;
    this.x1=x1;
    this.y1=y1;
    this.x2=x2;
    this.y2=y2;
    }
  init(cont) {
  var alphi = cont;
  //var alphi =this.iangle;
  var halphi = alphi / 2;
  var V = createVector(this.x1 * cos(cont), this.y1);
  //var V = createVector(this.x1, this.y1);
  var D = createVector(this.x2, this.y2);
  var alphi0 = atan2(D.y - V.y, D.x - V.x);
  var dds = dist(V.x, V.y, D.x, D.y);
  var dc = this.p2c(V, dds, alphi0);
  var lea = alphi0 + halphi;
  var ria = alphi0 - halphi;
  var sel = this.p2c(V, 1300, lea);
  var ser = this.p2c(V, 1300, ria);
  var tl = this.perpendPL(V, sel, D);
  var r = dist(D.x, D.y, tl.x, tl.y);
  var np =this.p2c(D, r, alphi0 - PI);
  var np0 = np;
  var nd = this.p2c(D, r, alphi0);
  var cp = this.c2pt(nd, tl, D);
  var T1 = this.findIntersection(D, cp, V, sel);
  var cq = this.c2pt(tl, D, T1);
  var C = this.findIntersection(T1, cq, D, V);
  var dd = dist(C.x, C.y, T1.x, T1.y);
  var pt2 = this.perpendPL(D, V, T1);
  var T2 = this.findIntersection(T1, pt2, V, ser);
  shape2.fill(20);
  shape2.noStroke();
  shape2.ellipse(C.x, C.y, dd * 2, dd * 2, 60);
  shape2.beginShape();
  shape2.vertex(V.x, V.y);
  shape2.vertex(T2.x, T2.y);
  shape2.vertex(T1.x, T1.y);
  shape2.endShape(CLOSE);

 
}
   p2c(p, r, an) {
  // Polar to cartesians
  const x = p.x + r * cos(an);
  const y = p.y + r * sin(an);
  return { x, y };
}
 c2p(p1, p2) {
  // Cartesians to Polar
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var r = sqrt(dx * dx + dy * dy);
  var a = atan2(dy, dy);
  if (a < 0) {
    a += 2 * PI;
  }
  return { r: r, a: a };
}
 c2pt(p1, p2, p3) {
  p1 = createVector(p1.x, p1.y);
  p2 = createVector(p2.x, p2.y);
  p3 = createVector(p3.x, p3.y);
  let r = dist(p1.x, p1.y, p2.x, p2.y);
  let theta = atan2(p2.y - p1.y, p2.x - p1.x);
  var p4 = createVector();
  p4.x = p3.x + r * 2 * cos(theta);
  p4.y = p3.y + r * 2 * sin(theta);

  return p4;
}
 perpendPL(A, B, P) {
  // perpendicular from point to line
  const m = (B.y - A.y) / (B.x - A.x);
  const m_perp = -1 / m;
  const Ix = (P.y - m_perp * P.x - A.y + m * A.x) / (m - m_perp);
  const Iy = m * (Ix - A.x) + A.y;
  if (isNaN(Ix) || isNaN(Iy)) {
    return { x: P.x + 100, y: P.y };
  }
  return { x: Ix, y: Iy };
}

  findIntersection(p1, p2, q1, q2) {
  let A1 = p2.y - p1.y;
  let B1 = p1.x - p2.x;
  let C1 = A1 * p1.x + B1 * p1.y;

  let A2 = q2.y - q1.y;
  let B2 = q1.x - q2.x;
  let C2 = A2 * q1.x + B2 * q1.y;
  let det = A1 * B2 - A2 * B1;
  if (det === 0) {
    console.log("are paralel");
    return null;
  } else {
    let x = (B2 * C1 - B1 * C2) / det;
    let y = (A1 * C2 - A2 * C1) / det;
    return { x: x, y: y };
  }
}

}  

    </script>
</body>

</html>